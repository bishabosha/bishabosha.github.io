<!DOCTYPE html><html><head><meta charset="utf-8" /><meta name="Content-Type" content="text/html; charset=utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" /><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.0/css/bootstrap.css" /><link rel="stylesheet" href="/static/css/style_c68de8e5aafce1452e37d2687a1dc351.css" /><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.2/css/all.min.css" crossorigin="anonymous" /><title>Port Mill build.sc files to Scala 3 | bishabosha</title><meta name="description" content="Enhance the Mill build tool (github.com/com-lihaoyi/mill) by enabling users to write build.sc files with Scala 3 syntax and libraries." /><meta name="twitter:card" content="summary" /><meta name="twitter:title" content="Port Mill build.sc files to Scala 3 | bishabosha" /><meta name="twitter:site" content="@bishabosha" /><meta name="twitter:description" content="Enhance the Mill build tool (github.com/com-lihaoyi/mill) by enabling users to write build.sc files with Scala 3 syntax and libraries." /><meta name="og:title" content="Port Mill build.sc files to Scala 3 | bishabosha" /><meta name="og:description" content="Enhance the Mill build tool (github.com/com-lihaoyi/mill) by enabling users to write build.sc files with Scala 3 syntax and libraries." /><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.6.0/styles/default.min.css" /><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.9/katex.min.css" /><script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.9/katex.min.js" type="text/javascript"></script><link rel="stylesheet" href="/static/css/admonition_972c50a2320249eebf61150270d503dc.css" /></head><body class="d-flex flex-column min-vh-100"><nav class="navbar navbar-expand-md navbar-light fixed-top bg-light"><div class="container-fluid"><a class="navbar-brand navbar-slash" href="/">bishabosha</a><button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav me-auto mb-2 mb-lg-0"><li class="nav-item"><a class="nav-link" href="/about/">About</a></li><li class="nav-item"><a class="nav-link" href="/articles/">Articles</a></li><li class="nav-item"><a class="nav-link active" aria-current="page" href="/projects/">Projects</a></li><li class="nav-item"><a class="nav-link" href="/talks/">Talks</a></li></ul></div></div></nav><div class="container"><div class="row"><div class="col-lg-4"><div class="bio-box jumbotron sidebar shadow py-lg-4 py-3 bio-box__top"><div class="bio-main"><table><tr><td class="bio-left"><div class="bio-photo"><img src="/static/img/jamie_thompson_profile.png" alt="photo of bishabosha" class="img-avatar" /></div></td><td class="bio-right"><p><span class="bio-name">Jamie Thompson</span></p></td></tr></table><ul class="list-inline"><li class="list-inline-item"><p class="text-center mb-1"><small><a href="https://github.com/bishabosha" class="bio-link" rel="me"><i class="fa-brands fa-github fa-lg"></i><br />GitHub</a></small></p></li><li class="list-inline-item"><p class="text-center mb-1"><small><a href="https://twitter.com/bishabosha" class="bio-link" rel="me"><i class="fa-brands fa-twitter fa-lg"></i><br />Twitter</a></small></p></li><li class="list-inline-item"><p class="text-center mb-1"><small><a href="https://www.linkedin.com/in/james-richard-thompson/" class="bio-link" rel="me"><i class="fa-brands fa-linkedin fa-lg"></i><br />LinkedIn</a></small></p></li><li class="list-inline-item"><p class="text-center mb-1"><small><a href="https://fosstodon.org/@jrthompson" class="bio-link" rel="me"><i class="fa-brands fa-mastodon fa-lg"></i><br />Mastodon</a></small></p></li><li class="list-inline-item"><p class="text-center mb-1"><small><a href="/static/pages/generalJamesThompsonresume2024.html" class="bio-link"><i class="fa-solid fa-file fa-lg"></i><br />Resume</a></small></p></li></ul><div class="d-none d-sm-none d-lg-block"><hr /><div class="bio-body bio-expand" tabindex="0"><p>Freelancing, previously hacking compilers at the <a href="https://scala.epfl.ch" target="_blank">Scala Center</a>.</p>
<p>I love to share ideas about programming, whether it is though speaking,
producing video tutorials, or engaging in the learning process to deliver the best materials for newcomers.</p>
<p>As a software engineer, my passions are programming language design, and simplifying APIs.</p>
</div></div></div></div><div class="sticky-top top-aligned jumbotron sidebar shadow py-lg-4 py-3"><nav class="toc-nav"><ol class="list-unstyled"><li class="toc-level-1"><a href="#port-mill-build.sc-files-to-scala-3.html">Port Mill build.sc files to Scala 3</a></li><li class="toc-level-2"><a href="#about-the-project">About the Project</a></li><li class="toc-level-2"><a href="#current-status">Current Status</a></li><li class="toc-level-2"><a href="#progress-diary">Progress Diary</a></li><li class="toc-level-3"><a href="#2024-aug-05">2024-aug-05</a></li><li class="toc-level-3"><a href="#2024-aug-06">2024-aug-06</a></li><li class="toc-level-3"><a href="#2024-aug-07">2024-aug-07</a></li><li class="toc-level-3"><a href="#2024-aug-08">2024-aug-08</a></li><li class="toc-level-3"><a href="#2024-aug-09">2024-aug-09</a></li><li class="toc-level-3"><a href="#2024-aug-12">2024-aug-12</a></li><li class="toc-level-3"><a href="#2024-aug-13">2024-aug-13</a></li><li class="toc-level-3"><a href="#2024-aug-14">2024-aug-14</a></li><li class="toc-level-3"><a href="#2024-aug-16">2024-aug-16</a></li><li class="toc-level-3"><a href="#2024-aug-20">2024-aug-20</a></li><li class="toc-level-3"><a href="#2024-aug-21">2024-aug-21</a></li><li class="toc-level-3"><a href="#2024-aug-22">2024-aug-22</a></li><li class="toc-level-3"><a href="#2024-aug-23">2024-aug-23</a></li><li class="toc-level-3"><a href="#2024-aug-27">2024-aug-27</a></li><li class="toc-level-3"><a href="#2024-sep-04">2024-sep-04</a></li><li class="toc-level-3"><a href="#2024-sep-06">2024-sep-06</a></li></ol></nav></div></div><div class="col-lg-8"><div class="jumbotron bg-light py-lg-5 py-3"><article><h1 id="port-mill-build.sc-files-to-scala-3.html" class="display-5 anchor-link__source"><img src="/static/img/mill-logo-white.svg" alt="Project 1 Icon" class="mr-2 bg-dark p-1 img-icon" />Port Mill build.sc files to Scala 3</h1><ul class="list-inline mb-2"><li class="list-inline-item"><small><span class="text-muted">Start: Aug/2024</span></small></li><li class="list-inline-item"><small><i class="fa-solid fa-hourglass-start"></i> 14 minute read</small></li><li class="list-inline-item"><small><a href="/projects/"><i class="fa-solid fa-angle-up"></i> all projects</a></small></li></ul><hr /><blockquote><p><a href="https://github.com/com-lihaoyi/mill/pull/3369" target="_blank"><small><i class="fa-solid fa-arrow-up-right-from-square"></i></small> Project URL</a><b> this project is still in progress...</b></p><p><i><b>Summary: </b>Enhance the Mill build tool (github.com/com-lihaoyi/mill) by enabling users to write build.sc files with Scala 3 syntax and libraries.</i></p></blockquote><div><h2><a href="#about-the-project" id="about-the-project" class="anchor-link anchor-link__source"><i class="fa-solid fa-link"></i></a>About the Project</h2>
<p>The <a href="https://mill-build.org">Mill build tool</a> lets users write build pipelines in the Scala programming language.
It provides a DSL that makes it simple for users to build a graph of tasks, and dependencies between them, and Mill provides a command line interface to invoke these tasks.</p>
<p>As of August 2024, Mill build definitions are locked to the latest Scala 2.13 version.
This prevents users and plugin authors from benefitting from the latest additions in Scala 3, which first launched in 2021.</p>
<p>The goal of this project is to make it possible to use the latest Scala 3 version (as of writing Scala 3.5.0) to define Mill builds.
This isn't a standard migration effort however, as Mill customises the language in various ways:</p>
<ul>
<li>Macros to support the direct-style task DSL. (Macros have a brand new API in Scala 3)</li>
<li>Macros to reflect the tasks to the CLI resolution mechanism.</li>
<li>Custom Scala parser to detect special imports such as dependencies or the meta-build.</li>
<li>Compiler plugins to support script files and Module definitions.</li>
<li>Bytecode analyzers to detect changes in the build.</li>
</ul>
<h2><a href="#current-status" id="current-status" class="anchor-link anchor-link__source"><i class="fa-solid fa-link"></i></a>Current Status</h2>
<p>As of August 21st 2024, the project is in progress (<a href="https://github.com/com-lihaoyi/mill/pull/3369">with a PR to Mill</a>). Most macros, and override inferrence are ported, meaning that we can compile all of core Mill, and even compile many integration test builds.</p>
<p>The next step would be to port the cross-module macros, which should pass all existing integration tests.</p>
<p>Here is a gif of compiling a Mill project where the build.sc file is compiled with Scala 3.5.0:</p>
<p><img src="/static/img/projects/mill-scala3-milestone1.gif" class="img-fluid" alt="compiling a Mill project where the build itself is compiled with Scala 3.5.0" /></p>
<h2><a href="#progress-diary" id="progress-diary" class="anchor-link anchor-link__source"><i class="fa-solid fa-link"></i></a>Progress Diary</h2>
<p>Below is a log of the progress made on this project.</p>
<h3><a href="#2024-aug-05" id="2024-aug-05" class="anchor-link anchor-link__source"><i class="fa-solid fa-link"></i></a>2024-aug-05</h3>
<ul>
<li>Setup project, reading build definition</li>
<li>Asked Haoyi about acyclic plugin
<ul>
<li>Conclusion - ignore for now, nice to have</li>
<li>Remove it from compile deps when scalaversion is 3.x</li>
</ul>
</li>
<li>Build definition is pretty big - so i discover the entry points to try and work backwards
<ul>
<li><code>mill.runner.MillMain</code>, <code>mill.runner.MillServerMain</code>, and <code>mill.main.client.MillClientMain</code>.</li>
</ul>
</li>
<li>Also look at understanding how the inprocess example test suites are invoked,
<ul>
<li>Starting from command <code>./mill 'example.basic[1-simple].local'</code> I see in the build that <code>example.basic</code> is a cross module, and inside that the <code>local</code> module extends <code>TestModule</code>.</li>
<li>I show the <code>discoveredTestClasses</code> target on <code>example.basic[1-simple].local</code> and find that it is running <code>mill.example.ExampleTestSuite</code>.</li>
</ul>
</li>
<li>Understanding how <code>mill.example.ExampleTestSuite</code> works.
<ul>
<li>See that in <code>local</code> mode it invokes the mill launcher produced by <code>dev.launcher</code> repeatedly. (which invokes the <code>mill.main.client.MillClientMain</code> class)</li>
<li><code>mill.runner.MillServerMain</code> gets started by MillClientMain, before running the main of <code>mill.runner.MillMain</code></li>
</ul>
</li>
<li>Looking at <code>MillBuildBootstrap</code>
<ul>
<li>Found the part where Mill parses build.sc files.</li>
</ul>
</li>
<li>Try to build the <code>dev.runner</code> target by changing <code>scalaVersion</code> to <code>3.5.0-RC6</code>.</li>
<li>First update the tasks in the <code>bridge</code> cross module to resolve the dotty sbt-bridge module.</li>
<li>Edits to <code>main.api</code> module:
<ul>
<li>Had to fix some extension method problem with Array.map</li>
<li>Manually define Mirror for JarManifest (to derive upickle RW) because it isn’t a case class.</li>
<li>Agg had some new problems automatically mixing-in collect and zipWithIndex, so they are overridden manually. Also ++ is final so override in Agg is removed</li>
</ul>
</li>
<li>Edits to <code>main.util</code> module:
<ul>
<li>Use 2.13 binary suffix in coursier dep</li>
<li>Fix extension method issue with coursier.ResolutionExtensions</li>
</ul>
</li>
<li>Edits to <code>main.define</code> module:
<ul>
<li>Remove <code>mill-moduledefs</code> plugin temporarily - will be necessary later to support <code>override</code> insertion.</li>
<li>Don’t include <code>scala-reflect</code> on classpath</li>
<li>Use 2.13 binary suffix in jarjarabrams dep</li>
<li>Comment out macros definitions in <code>Task.scala</code></li>
</ul>
</li>
</ul>
<h3><a href="#2024-aug-06" id="2024-aug-06" class="anchor-link anchor-link__source"><i class="fa-solid fa-link"></i></a>2024-aug-06</h3>
<ul>
<li>Edits to <code>main.define</code> module:
<ul>
<li>(identified fastparse usage in <code>Reflect.scala</code>)</li>
<li>Comment out macros in <code>Discover.scala</code></li>
<li>Comment out macros in <code>Applicative.scala</code></li>
<li>Copy implementation of <code>mill.moduledefs.Cacher</code> for <code>Module.BaseClass</code>.</li>
<li>Comment out macro of <code>Caller.scala</code></li>
<li>Comment out Factory macro in <code>Cross.scala</code></li>
<li>Comment out macro of <code>EnclosingClass.scala</code></li>
<li>Comment out macro impl in <code>Task.scala</code></li>
</ul>
</li>
<li>Edits to <code>main.eval</code> module:
<ul>
<li>Change syntax of explicit context parameter passing</li>
</ul>
</li>
<li>Edits to <code>main.resolve</code> module:
<ul>
<li>Change syntax of explicit context parameter passing</li>
<li>(identified fastparse usage in <code>ExpandBraces.scala</code>)</li>
<li>(identified fastparse usage in <code>ParseArgs.scala</code>)</li>
<li>Change syntax of pattern matching for comprehension</li>
</ul>
</li>
<li>Edits to <code>main</code> module
<ul>
<li>Remove scala-reflect from compile classpath</li>
<li>Copy implementation of <code>mill.moduledefs.Scaladoc</code> for <code>MainModule.scala</code>.</li>
<li>Make <code>Target.log</code> inline (in <code>main.define</code>) so that it drops the ctx argument (avoiding compiletimeonly errors)</li>
<li>Make <code>Applyer.ctx()</code> inline (in <code>main.define</code>) so that it drops the ctx argument (avoiding compiletimeonly errors)</li>
<li>Make <code>Applyable.apply()</code> inline (in <code>main.define</code>) so that it drops the handler argument (avoiding compiletimeonly errors)</li>
<li>Temporarily remove ctx argument from <code>ClassLoader.create</code> in (in <code>main.api</code>)</li>
</ul>
</li>
<li>Edits to <code>scalalib</code> module:
<ul>
<li>Use 2.13 binary suffix on <code>scalafmt-dynamic</code> dep</li>
<li>Temporarily add <code>@mainargs.main</code> annotation to <code>IvyDepsTreeArgs</code> so compilation continues - opened <a href="https://github.com/com-lihaoyi/mainargs/issues/143">https://github.com/com-lihaoyi/mainargs/issues/143</a> to track problem</li>
<li>Fix syntax of lambda parameters</li>
<li>Reimplement <code>scala.tools.nsc.io.Streamable.bytes</code></li>
<li>Generate Mirrors for types in <code>JsonFormatters.scala</code></li>
<li>(identified fastparse usage in <code>VersionParser.scala</code>)</li>
<li>Comment out majority of <code>PublishModule.scala</code></li>
</ul>
</li>
<li>Now I am seeing that <code>Task</code> is pretty much everywhere at this point, and too much to comment away/remove <code>Ctx</code> from signatures, so likely not going to progress much without implementing it properly.
<ul>
<li>Remove any <code>compileTimeOnly</code> annotations (for now)</li>
<li>Restore signatures of <code>ctx</code> accessors in <code>Tasks.scala</code>, and <code>Applicative.scala</code>, and restore <code>ClassLoader.create</code>.</li>
<li>Restore all code in  <code>PublishModule.scala</code></li>
<li>Add import to help derive RW for <code>PublishData</code>.</li>
</ul>
</li>
<li>Edits to <code>scalalib.worker</code> module:
<ul>
<li>Change classpath of zinc module and scalap</li>
</ul>
</li>
<li>Edits to <code>scalajslib</code> module:
<ul>
<li>Generate Mirrors for classes and objects in <code>ScalaJSApi.scala</code> and <code>Report.scala</code></li>
</ul>
</li>
<li>Edits to <code>bsp</code> module:
<ul>
<li>Generate mirrors for <code>BspServerResult</code></li>
</ul>
</li>
<li>Edits to <code>codesig</code> module
<ul>
<li>Fix syntax and type inference</li>
</ul>
</li>
<li>Edits to <code>runner</code> module
<ul>
<li>Temporarily remove <code>linenumbers</code> dependency</li>
<li>Fix lambda syntax</li>
<li>Fix explicit context bound passing</li>
<li>(identified fastparse usage in <code>Parsers.scala</code>)</li>
<li>Temporarily disable mainarg parsing for <code>MillCliConfig</code>. (because of a crash caused by a type mismatch in default parameters)</li>
</ul>
</li>
<li>Edits to <code>dev</code> module:
<ul>
<li>Comment out some contrib deps not necessary to run example.basic test suite,</li>
<li>(also some minor fixes to classpath of contrib.bloop, and syntax of contrib.buildInfo)</li>
</ul>
</li>
<li>Now I can run <code>example.basic[1-simple].local</code> but it fails due to all the <code>???</code> I added in.
<ul>
<li>Primarily the <code>MillCliConfig</code> mainargs parser - so we can work backwards from this.</li>
</ul>
</li>
</ul>
<h3><a href="#2024-aug-07" id="2024-aug-07" class="anchor-link anchor-link__source"><i class="fa-solid fa-link"></i></a>2024-aug-07</h3>
<ul>
<li>I cloned a local version of mainargs to try and debug the problem in <code>MillCliConfig</code>.
<ul>
<li>First I tried to print the actual types of the arguments that were mismatched, it turned out I got a <code>Leftover[String]</code> when <code>Flag</code> was expected.</li>
<li>Then i printed the parameters of the apply method that was selected, it turned out it was the overloaded “shim” apply method.</li>
<li>So I published locally a fix to mainargs to select the apply method where the names of parameters match the class constructor. (in reality perhaps we should invent a new annotation to deterministically declare which method to pick for the class parser?)</li>
<li>Also took the opportunity to create a default main annotation if none was found. So i removed main annotations from <code>MillCliConfig</code> and from <code>IvyDepsTreeArgs</code></li>
</ul>
</li>
<li>With the locally published mainargs, i updated the mill build to use it, and could revert any changes made previously and the build worked.</li>
<li>Now the next unimplemented error in <code>example.basic[1-simple].local</code> is the <code>Discover</code> macro.</li>
<li>Edits to the <code>main.define</code> module:
<ul>
<li>I implement the <code>Discover</code> macro, it seems to be mostly portable exactly as before - i notice however it does a funny thing - it imports all the given <code>TokenReaders</code> from the <code>main</code> module, which is not possible to do in quotes because they must be well typed at definition.</li>
<li>When i run the discover macro on <code>RootModule.Foreign</code> it crashes because for some reason the typeMembers returned by dotty includes the NoSymbol, so i had to explicitly filter that out - however that should be a bug in dotty.</li>
<li>Next error - there is an “reference to parameter <code>b</code> was used outside its scope in inlining phase”, which is an internal dotty error so i can’t catch it in the macro. By searching for <code>b:</code> In both mill and mainargs, i found that <code>b</code> is the parameter of a quoted lambda in the <code>mainargs</code> library - because I renamed it to <code>bSpooky</code> and the error message changed accordingly.</li>
<li>Turns out it was solved by swapping the type arguments of createMainData,</li>
<li>Now the problem is that mainargs does not do varargs adaption - e.g. <code>MainModule.clean</code></li>
<li>Implement in mainargs the varargs adaption trick copied from upickle.</li>
<li>Next I saw that the default argument parsing for mainargs was again incorrect when there are several overloaded commands. I ignore defaults in mainargs when the method has no defaults by checking for the flag HasDefaults.</li>
<li>Now there is one last discovery error: “<code>invalid new prefix = JavaModule.this.JavaModuleTests cannot replace (JavaModule.this : mill.scalalib.JavaModule) in type JavaModule.this.JavaModuleTests</code>” not sure where this comes from, will need investigation. - The problem was to do with path dependent types - mainargs isn’t resolving default accessors properly, because it needs a prefix to select from.</li>
</ul>
</li>
</ul>
<h3><a href="#2024-aug-08" id="2024-aug-08" class="anchor-link anchor-link__source"><i class="fa-solid fa-link"></i></a>2024-aug-08</h3>
<ul>
<li>Edits to the <code>main.define</code> module:
<ul>
<li>I filter out synthetic methods in the discover macro, (i found that a superaccessor was being generated as a command - due to an override)</li>
<li>also switch to only scanning module values in Discover.</li>
<li>In lieu of fixing mainargs, i manually created a Discover instance with code gen for <code>MillBuildBootstrap (MillBuildRootModule.BootstrapModule)</code> - which was a pain.</li>
<li>I fixed mainargs to select the default getter from the lambda parameter, which means it works for non-static getters. So i deleted the manual discover instance, and could restore any commented out Discover macro callsites.</li>
<li>Now all <code>Discover</code> macro call sites are building (perhaps implementation is still not 1:1 with scala 2? Needs more testing)</li>
<li>Now the next <code>unimplementedError</code> problem in the <code>example.basic[1-simple].local</code> test is <code>Caller</code> macro.</li>
</ul>
</li>
</ul>
<h3><a href="#2024-aug-09" id="2024-aug-09" class="anchor-link anchor-link__source"><i class="fa-solid fa-link"></i></a>2024-aug-09</h3>
<p>Trying to implement the caller macro - it seems not possible to implement correctly in extends clauses - so i opened <a href="https://github.com/scala/scala3/issues/21358">https://github.com/scala/scala3/issues/21358</a> - perhaps we should have 2 subclasses of <code>Caller</code> so one is for methods (where enclosing class is correct), and one for extends clauses (where we need to get the class outside the current class) - waiting on comment from Haoyi</p>
<ul>
<li>Based on comment - i remove the <code>Caller.generate</code> macro, instead define an implicit within Module that returns itself - this will perform the equivalent as the macro</li>
<li>Now next unimplementedError in <code>example.basic[1-simple].local</code> is <code>Target.apply</code></li>
</ul>
<h3><a href="#2024-aug-12" id="2024-aug-12" class="anchor-link anchor-link__source"><i class="fa-solid fa-link"></i></a>2024-aug-12</h3>
<ul>
<li>Attempting to fix the Target.apply macro - for now i construct the TargetImpl object with placeholder values - now Applicative <code>defaultApplyHandler</code> (previously compiletimeonly) is being reached, so we do need to implement the <code>Target.apply</code> macro to eliminate this.</li>
<li>Start implementing Task.apply (implicit conversion macro) - and implement detection of if target owner is private - but now i need two other macro definitions - Cacher.impl0 and Applicative.impl0</li>
<li>Implemented Applicative macro - needed to manually pass in the caller rather than <code>c.internal.prefix</code> - this isn’t part of quoted api. Also I needed to add more precise types to help with actually typing the inner expression.</li>
<li>This lead to the <code>Target.task</code> macro being next to fail, so I implemented that, followed by <code>Target.sources</code> (<code>sourcesImpl2</code>), followed by <code>Target.inputs</code> and finally <code>Target.sources</code> (<code>sourcesImpl1</code>).</li>
<li>Now at this point i get to <code>MillBuildRootModule.lineNumberPluginClasspath</code> in the example test, and it tries to evaluate <code>defaultApplyHandler</code> - so either this macro wasnt handled yet, or there is a bug in the macro to not eliminate it. However it seems to just be <code>Task.apply</code> (with result input) is not implemented.</li>
<li>Next <code>defaultApplyHandler</code> is from ScalaModule.compile - which is the unimplemented <code>T.persistent</code> macro</li>
<li>Next was failing the <code>Target.worker</code>.</li>
<li>Then <code>Target.apply</code> (of a Task)</li>
<li>Next only errors were to fix the <code>???</code> in coursier module, but now i have a test failure that isn’t to do with unimplementedError - so will need to debug that. But for now i will focus on restoring compileTimeOnly annotations to be sure rewrites are correct.</li>
<li>Now implementing all remaining Target macros</li>
<li>Determined that the fault is due to the default classpath of the mill bootstrap module - will have to enable more debugging info so i can see exactly what isn’t resolved.</li>
</ul>
<h3><a href="#2024-aug-13" id="2024-aug-13" class="anchor-link anchor-link__source"><i class="fa-solid fa-link"></i></a>2024-aug-13</h3>
<ul>
<li>Classpath resolution is failing in an opaque manor, because it is just throwing an exception inside a task - so I added a new <code>resolveDeps0</code> method to the <code>CoursierModule.Resolver</code> that returns its resolution as a <code>Result</code>, this means we can propagate resolution errors correctly to the <code>ScalaModule.scalaCompilerClasspath</code> task.</li>
<li>Identifying the missing dependencies as some compiler plugins so need to remove those temporarily.</li>
<li>Then ZincWorkerImpl was having issues resolving <code>scala-library</code> from the compiler classpath when building the <code>mill-build</code> task - which is correct as the resolution of the <code>Lib.scalaRuntimeIvyDeps</code> deps was excluding <code>scala-library</code> - which i discovered by printing the deps before resolution. This exclusion comes from <code>MillBuildRootModule.resolveDepsExclusions</code> as it is part of the classpath of mill itself - so i made an exception to excluding the scala-library for the mill root build - perhaps there is a better and localised solution?</li>
<li>Next i discovered in running example test that the generated script file discover macro needed explicit TokenReader imports so added that.</li>
<li>Now i can actually run many integration tests out of the box - e.g. <code>example.tasks[1-task-graph].local</code>. - i am still relying on my locally published mainargs however - so should quickly submit some PR for that to be released.</li>
<li>With some integration tests passing locally I opened a <a href="https://github.com/com-lihaoyi/mill/pull/3369">PR to Mill</a></li>
<li>Some features which are necessary to pass more integration tests are
<ul>
<li><code>mill-moduledefs</code> compiler plugin to infer override keywords, and insert annotations that record scaladoc comments. (although we can access the scaladoc of a method via macros? - it seems java reflection resolves this info in the task but maybe we could redesign)</li>
<li><code>mill-runner-linenumbers</code> compiler plugin to fix line numbers of trees (is this even allowed in dotty?)</li>
</ul>
</li>
<li>Got encouragement to open a mainargs PR to add my fixes - so then prepared my changes for a PR - while adding restoring unit tests for vararg handling, i noted that the parsing at runtime was actually incorrect - so what was needed is to copy the Scala 2 implementation - convert the parameter type from <code>T*</code> to <code>Leftover[T]</code> to create the <code>ArgSig</code>. Then at the callsite you still need a vararg value, but the argument will need to be converted from <code>Leftover[T]</code> back to <code>T*</code>. I will add unit tests for the path dependent type handling of default args, Classparser for classes without <code>@main</code>, and the overloaded apply method in companion for classparser.</li>
</ul>
<h3><a href="#2024-aug-14" id="2024-aug-14" class="anchor-link anchor-link__source"><i class="fa-solid fa-link"></i></a>2024-aug-14</h3>
<ul>
<li>Spent the day adding unit tests to mainargs to prepare for a pull request, <a href="https://github.com/com-lihaoyi/mainargs/pull/148">opening it</a> at the end of the day.</li>
<li>Also forked the mill-moduledefs repo, fixed the build.sc to set up cross building both library and compiler plugin for scala 2.13 and 3.5.0.</li>
</ul>
<h3><a href="#2024-aug-16" id="2024-aug-16" class="anchor-link anchor-link__source"><i class="fa-solid fa-link"></i></a>2024-aug-16</h3>
<ul>
<li><a href="https://github.com/com-lihaoyi/mainargs/pull/148">Mainargs PR</a> was merged, released in version 0.7.2. I updated my <a href="https://github.com/com-lihaoyi/mill/pull/3369">Mill PR</a> to include the new dependency and GitHub actions CI now records several integration tests passing, such as <code>example.tasks[6-workers].local</code></li>
</ul>
<h3><a href="#2024-aug-20" id="2024-aug-20" class="anchor-link anchor-link__source"><i class="fa-solid fa-link"></i></a>2024-aug-20</h3>
<ul>
<li>Implemented the <code>EnableScaladocAnnotation</code> phase in the mill-moduledefs compiler plugin. It’s greatly simplified from scala 2 as dotty makes it easy to access documentation for symbols, and Its easier to create annotations. I had to make some tweaks - adjust <code>runsAfter</code> to be <code>”posttyper”</code> rather than <code>”parser”</code> (standard plugin must be after typer). Also I had to adjust <code>build.sc</code> again to hardcode the artifact name due to the outer module now being a cross module.</li>
</ul>
<h3><a href="#2024-aug-21" id="2024-aug-21" class="anchor-link anchor-link__source"><i class="fa-solid fa-link"></i></a>2024-aug-21</h3>
<ul>
<li>Implemented the <code>AutoOverride</code> phase in mill-moduledefs, now the plugin is finished - opened a <a href="https://github.com/com-lihaoyi/mill-moduledefs/pull/14">PR</a> after some cleanups.</li>
<li>Fixed the <code>millProjectModule</code> to have <code>_3</code> suffix by default - now all of example.basic integration tests are passing except <code>4-builtin-commands</code> - for some reason the <code>showUpdates</code> command is failing - upon investigation - it seems that it is overloaded, and the <code>Discover</code> macro picks the wrong one (i.e. the deprecated one with no default arguments) - will need to fix this.</li>
<li>Went with the fix of filtering out deprecated methods in the Discover macro, which fixed the test. Now all <code>example.basic</code> tests are passing locally. Next for integration tests would be the <code>Cross</code> macro.</li>
<li>Next I discovered that my patch to build scripts to include the empty package prefix was wrong - multi build roots now mean that there can be nested packages in the prefix - so I adjusted the code generation there - now passing all of <code>example.misc</code> tests.</li>
</ul>
<h3><a href="#2024-aug-22" id="2024-aug-22" class="anchor-link anchor-link__source"><i class="fa-solid fa-link"></i></a>2024-aug-22</h3>
<ul>
<li><a href="https://github.com/com-lihaoyi/mill-moduledefs/pull/14">mill-moduledefs PR</a> was merged, changes released in 0.11.0-M1. I rebased my Mill PR, which revealed another type inference issue (solved with an explicit type).</li>
</ul>
<h3><a href="#2024-aug-23" id="2024-aug-23" class="anchor-link anchor-link__source"><i class="fa-solid fa-link"></i></a>2024-aug-23</h3>
<ul>
<li>Began work on <code>Cross.Factory</code> macro. I realised I could not proceed without using the experimental methods <code>Symbol.newClass</code> and <code>ClassDef.apply</code>. Moreover, these methods are not adequate because they do not allow to customise the primary constructor, which was necessary to add the Context parameter. I knew I would have to rely upon compiler internals - so I decided to implement a Shim interface in the <code>mill-moduledefs</code> library, with an implementation provided by the <code>scalac-mill-moduledefs-plugin</code> library. I tried this and realised that the plugin library isn’t on the classpath when loading macros, so this didn’t work.</li>
<li>I asked the Discord channel for advice and Haoyi said it would be permissible to use compiler internals even in the <code>main.define</code> module.</li>
</ul>
<h3><a href="#2024-aug-27" id="2024-aug-27" class="anchor-link anchor-link__source"><i class="fa-solid fa-link"></i></a>2024-aug-27</h3>
<ul>
<li>I implemented the Shims inside <code>main.define</code> module and finished the <code>Cross.Factory</code> macro</li>
</ul>
<h3><a href="#2024-sep-04" id="2024-sep-04" class="anchor-link anchor-link__source"><i class="fa-solid fa-link"></i></a>2024-sep-04</h3>
<ul>
<li>Cleaned the code and pushed my changes to implement the <code>Cross.Factory</code> macro.</li>
</ul>
<h3><a href="#2024-sep-06" id="2024-sep-06" class="anchor-link anchor-link__source"><i class="fa-solid fa-link"></i></a>2024-sep-06</h3>
<ul>
<li>Investigated and fixed two problems related to the <code>Discover</code> macro:
<ul>
<li>A. not scanning correctly the type argument of a cross module</li>
<li>The scala 2 method of an immediately invoked closure (to split bytecode into manageable size) was optimised away, so the large-project integration test was failing - changing this to an explicit def avoids the optimisation, so the test works again.</li>
</ul>
</li>
<li>At this point - it would seem most test failures are now due to misconfiguration of classpath dependencies. I need to investigate the <code>linenumbers</code> compiler plugin, before I can attempt to support new scala 3 syntax.</li>
</ul>
</div></article></div></div></div></div><footer class="mt-auto"><div class="footer-copyright text-center py-3"><small>© 2024 Jamie Thompson.<span class="text-muted"> Last published 06/Sep/2024</span></small></div></footer><script src="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/js/bootstrap.bundle.min.js" integrity="sha384-MrcW6ZMFYlzcLA8Nl+NtUVF0sA7MsXsP1UyJoMp4YLEuNSfAP+JcXn/tWtIaxVXM" crossorigin="anonymous"></script><script src="/static/js/nav-toc.js" type="text/javascript"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.5.1/highlight.min.js" type="text/javascript"></script><script src="/static/js/hljs-scala3.js" type="text/javascript"></script><script src="/static/js/hljs.js" type="text/javascript"></script><script src="/static/js/katex-render.js" type="text/javascript"></script><script src="/static/js/admonition.js" type="text/javascript"></script></body></html>