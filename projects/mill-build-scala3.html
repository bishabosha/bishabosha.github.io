<!DOCTYPE html><html><head><meta charset="utf-8" /><meta name="Content-Type" content="text/html; charset=utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" /><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.0/css/bootstrap.css" /><link rel="stylesheet" href="/static/css/style_28d0663040790cd23ff0c2e10c66384d.css" /><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.2/css/all.min.css" crossorigin="anonymous" /><title>Port Mill build.sc files to Scala 3 | bishabosha</title><meta name="description" content="Enhance the Mill build tool (github.com/com-lihaoyi/mill) by enabling users to write build.sc files with Scala 3 syntax and libraries." /><meta name="twitter:card" content="summary" /><meta name="twitter:title" content="Port Mill build.sc files to Scala 3 | bishabosha" /><meta name="twitter:site" content="@bishabosha" /><meta name="twitter:description" content="Enhance the Mill build tool (github.com/com-lihaoyi/mill) by enabling users to write build.sc files with Scala 3 syntax and libraries." /><meta name="og:title" content="Port Mill build.sc files to Scala 3 | bishabosha" /><meta name="og:description" content="Enhance the Mill build tool (github.com/com-lihaoyi/mill) by enabling users to write build.sc files with Scala 3 syntax and libraries." /><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.6.0/styles/default.min.css" /><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.9/katex.min.css" /><script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.9/katex.min.js" type="text/javascript"></script><link rel="stylesheet" href="/static/css/admonition_972c50a2320249eebf61150270d503dc.css" /></head><body class="d-flex flex-column min-vh-100"><nav class="navbar navbar-expand-md navbar-light fixed-top bg-light"><div class="container-fluid"><a class="navbar-brand navbar-slash" href="/">bishabosha</a><button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav me-auto"><li class="nav-item"><a class="nav-link" href="/about/">About</a></li><li class="nav-item"><a class="nav-link" href="/articles/">Articles</a></li><li class="nav-item"><a class="nav-link active" aria-current="page" href="/projects/">Projects</a></li><li class="nav-item"><a class="nav-link" href="/talks/">Talks</a></li></ul></div></div></nav><div class="container"><div class="row"><div class="col-lg-4"><div class="bio-box jumbotron sidebar shadow py-lg-4 py-3 bio-box__top"><div class="bio-main"><table><tr><td class="bio-left"><div class="bio-photo"><img src="/static/img/jamie_thompson_profile.png" alt="photo of bishabosha" class="img-avatar" /></div></td><td class="bio-right"><p><span class="bio-name">Jamie Thompson</span></p></td></tr></table><ul class="list-inline"><li class="list-inline-item"><p class="text-center mb-1"><small><a href="mailto:jamie.thompson@bath.edu" class="bio-link" target="_blank"><i class="fa-solid fa-envelope fa-lg"></i><br />E-Mail</a></small></p></li><li class="list-inline-item"><p class="text-center mb-1"><small><a href="https://github.com/bishabosha" class="bio-link" target="_blank" rel="me"><i class="fa-brands fa-github fa-lg"></i><br />GitHub</a></small></p></li><li class="list-inline-item"><p class="text-center mb-1"><small><a href="https://twitter.com/bishabosha" class="bio-link" target="_blank" rel="me"><i class="fa-brands fa-twitter fa-lg"></i><br />Twitter</a></small></p></li><li class="list-inline-item"><p class="text-center mb-1"><small><a href="https://www.linkedin.com/in/james-richard-thompson/" class="bio-link" target="_blank" rel="me"><i class="fa-brands fa-linkedin fa-lg"></i><br />LinkedIn</a></small></p></li><li class="list-inline-item"><p class="text-center mb-1"><small><a href="https://fosstodon.org/@jrthompson" class="bio-link" target="_blank" rel="me"><i class="fa-brands fa-mastodon fa-lg"></i><br />Mastodon</a></small></p></li></ul><div class="d-none d-sm-none d-lg-block"><hr /><div class="bio-body bio-expand" tabindex="0"><p>This is an archive for my thoughts on programming, past and future.</p>
<p>Also a place to gather all the links.</p>
<p><a href="https://jamie-thompson-dev.github.io/" target="_blank" rel="me"><strong>Business website</strong></a></p>
</div></div></div></div><div id="sidebar-anchor" class="sticky-top top-aligned jumbotron sidebar sidebar__mobile shadow py-lg-4 py-3"><div id="sidebar-toggler" class="sidebar_toggle"><i class="fa-regular fa-square-caret-right"></i></div><nav class="toc-nav"><ol class="list-unstyled"><li class="toc-level-1"><a href="#port-mill-build-sc-files-to-scala-3.html">Port Mill build.sc files to Scala 3</a></li><li class="toc-level-2"><a href="#about-the-project">About the Project</a></li><li class="toc-level-2"><a href="#current-status">Current Status</a></li><li class="toc-level-2"><a href="#progress-diary">Progress Diary</a></li><li class="toc-level-3"><a href="#2024-aug-05">2024-aug-05</a></li><li class="toc-level-3"><a href="#2024-aug-06">2024-aug-06</a></li><li class="toc-level-3"><a href="#2024-aug-07">2024-aug-07</a></li><li class="toc-level-3"><a href="#2024-aug-08">2024-aug-08</a></li><li class="toc-level-3"><a href="#2024-aug-09">2024-aug-09</a></li><li class="toc-level-3"><a href="#2024-aug-12">2024-aug-12</a></li><li class="toc-level-3"><a href="#2024-aug-13">2024-aug-13</a></li><li class="toc-level-3"><a href="#2024-aug-14">2024-aug-14</a></li><li class="toc-level-3"><a href="#2024-aug-16">2024-aug-16</a></li><li class="toc-level-3"><a href="#2024-aug-20">2024-aug-20</a></li><li class="toc-level-3"><a href="#2024-aug-21">2024-aug-21</a></li><li class="toc-level-3"><a href="#2024-aug-22">2024-aug-22</a></li><li class="toc-level-3"><a href="#2024-aug-23">2024-aug-23</a></li><li class="toc-level-3"><a href="#2024-aug-27">2024-aug-27</a></li><li class="toc-level-3"><a href="#2024-sep-04">2024-sep-04</a></li><li class="toc-level-3"><a href="#2024-sep-06">2024-sep-06</a></li><li class="toc-level-3"><a href="#2024-sep-09">2024-sep-09</a></li><li class="toc-level-3"><a href="#2024-sep-10">2024-sep-10</a></li><li class="toc-level-3"><a href="#2024-sep-11">2024-sep-11</a></li><li class="toc-level-3"><a href="#2024-sep-12">2024-sep-12</a></li><li class="toc-level-3"><a href="#2024-sep-13">2024-sep-13</a></li><li class="toc-level-3"><a href="#2024-sep-14">2024-sep-14</a></li><li class="toc-level-3"><a href="#2024-sep-15">2024-sep-15</a></li><li class="toc-level-3"><a href="#2024-sep-16">2024-sep-16</a></li><li class="toc-level-3"><a href="#2024-sep-17">2024-sep-17</a></li><li class="toc-level-3"><a href="#2024-sep-19">2024-sep-19</a></li><li class="toc-level-3"><a href="#2024-sep-20">2024-sep-20</a></li><li class="toc-level-3"><a href="#2024-sep-21">2024-sep-21</a></li><li class="toc-level-3"><a href="#2024-sep-23">2024-sep-23</a></li><li class="toc-level-3"><a href="#2024-sep-24">2024-sep-24</a></li><li class="toc-level-3"><a href="#2024-sep-25">2024-sep-25</a></li><li class="toc-level-3"><a href="#2024-sep-26">2024-sep-26</a></li><li class="toc-level-3"><a href="#2024-sep-27">2024-sep-27</a></li><li class="toc-level-3"><a href="#2024-oct-10">2024-oct-10</a></li><li class="toc-level-3"><a href="#2024-oct-12">2024-oct-12</a></li><li class="toc-level-3"><a href="#2024-oct-13">2024-oct-13</a></li><li class="toc-level-3"><a href="#2024-oct-14">2024-oct-14</a></li></ol></nav></div></div><div class="col-lg-8"><div class="jumbotron bg-light py-lg-5 py-3"><article><h1 id="port-mill-build-sc-files-to-scala-3.html" class="display-5 anchor-link__source"><img src="https://mill-build.org/_/logo-white.svg" alt="Project 1 Icon" class="mr-2 bg-dark p-1 img-icon" />Port Mill build.sc files to Scala 3</h1><ul class="list-inline mb-2"><li class="list-inline-item"><small><span class="text-muted">Start: Aug/2024</span></small></li><li class="list-inline-item"><small><i class="fa-solid fa-hourglass-start"></i> 29 minute read</small></li><li class="list-inline-item"><small><a href="/projects/"><i class="fa-solid fa-angle-up"></i> all projects</a></small></li></ul><hr /><div class="container mb-2"><div class="row"><div class="col d-flex"></div><div class="col d-flex flex-row-reverse"><small class="float-end"><a href="/projects/unrolled-methods-scala3.html">Add method unrolling to Scala 3 <i class="fa-solid fa-angle-right"></i></a></small></div></div></div><blockquote><p><a href="https://github.com/com-lihaoyi/mill/pull/3369" target="_blank"><small><i class="fa-solid fa-arrow-up-right-from-square"></i></small> Project URL</a><b> this project is still in progress...</b></p><p><i><b>Summary: </b>Enhance the Mill build tool (github.com/com-lihaoyi/mill) by enabling users to write build.sc files with Scala 3 syntax and libraries.</i></p></blockquote><div><h2><a href="#about-the-project" id="about-the-project" class="anchor-link anchor-link__source"><i class="fa-solid fa-link"></i></a>About the Project</h2>
<p>The <a href="https://mill-build.org">Mill build tool</a> lets users write build pipelines in the Scala programming language.
It provides a DSL that makes it simple for users to build a graph of tasks, and dependencies between them, and Mill provides a command line interface to invoke these tasks.</p>
<p>Before starting the project in August 2024, Mill build definitions were locked to the latest Scala 2.13 version.
This prevents users and plugin authors from benefitting from the latest additions in Scala 3, which first launched in 2021.</p>
<p>The goal of this project is to make it possible to use the latest Scala 3 version (as of writing Scala 3.5.0) to define Mill builds.
This isn't a standard migration effort however, as Mill customises the language in various ways:</p>
<ul>
<li>Macros to support the direct-style task DSL. (Macros have a brand new API in Scala 3)</li>
<li>Macros to reflect the tasks to the CLI resolution mechanism.</li>
<li>Custom Scala parser to detect special imports such as dependencies or the meta-build.</li>
<li>Compiler plugins to support script files and Module definitions.</li>
<li>Bytecode analyzers to detect changes in the build.</li>
</ul>
<h2><a href="#current-status" id="current-status" class="anchor-link anchor-link__source"><i class="fa-solid fa-link"></i></a>Current Status</h2>
<p>As of October 10th 2024, the project is in final stages (<a href="https://github.com/com-lihaoyi/mill/pull/3369">with a PR to Mill</a>).</p>
<p>All present tests are passing in the CI, and support is added for Scala 3 syntax in build files.
Rebasing is done to keep up with latest changes before Mill 0.12.0 releases.</p>
<p>Done:</p>
<ul>
<li>‚úÖ Check that bytecode analyzers work with Scala 3</li>
<li>‚úÖ Discover macro</li>
<li>‚úÖ Applicative macro</li>
<li>‚úÖ Caller macro</li>
<li>‚úÖ Cross.Factory macro</li>
<li>‚úÖ EnclosingClass macro</li>
<li>‚úÖ Task macros</li>
<li>‚úÖ Cacher macro</li>
<li>‚úÖ Moduledefs compiler plugin (override inferrence)</li>
<li>‚úÖ All core Mill modules compile with Scala 3.5.0</li>
<li>‚úÖ Fix Zinc reporter patch linenumbers of build scripts</li>
<li>‚úÖ Fix all library dependencies</li>
<li>‚úÖ Identify any possible hidden bugs discovered by testing Scala 3 code.</li>
<li>‚úÖ Support new Scala 3 syntax in build.sc files</li>
</ul>
<p>Still to do:</p>
<ul>
<li>üöß Port acyclic plugin to Scala 3 (optional, someone else may do this)</li>
</ul>
<p>Here is a gif of compiling a Mill project where the build.sc file is compiled with Scala 3.5.0:</p>
<p><img src="/static/img/projects/mill-scala3-milestone1.gif" class="img-fluid" alt="compiling a Mill project where the build itself is compiled with Scala 3.5.0" /></p>
<h2><a href="#progress-diary" id="progress-diary" class="anchor-link anchor-link__source"><i class="fa-solid fa-link"></i></a>Progress Diary</h2>
<p>Below is a log of the progress made on this project.</p>
<h3><a href="#2024-aug-05" id="2024-aug-05" class="anchor-link anchor-link__source"><i class="fa-solid fa-link"></i></a>2024-aug-05</h3>
<ul>
<li>Setup project, reading build definition</li>
<li>Asked Haoyi about acyclic plugin
<ul>
<li>Conclusion - ignore for now, nice to have</li>
<li>Remove it from compile deps when scalaversion is 3.x</li>
</ul>
</li>
<li>Build definition is pretty big - so i discover the entry points to try and work backwards
<ul>
<li><code>mill.runner.MillMain</code>, <code>mill.runner.MillServerMain</code>, and <code>mill.main.client.MillClientMain</code>.</li>
</ul>
</li>
<li>Also look at understanding how the inprocess example test suites are invoked,
<ul>
<li>Starting from command <code>./mill 'example.basic[1-simple].local'</code> I see in the build that <code>example.basic</code> is a cross module, and inside that the <code>local</code> module extends <code>TestModule</code>.</li>
<li>I show the <code>discoveredTestClasses</code> target on <code>example.basic[1-simple].local</code> and find that it is running <code>mill.example.ExampleTestSuite</code>.</li>
</ul>
</li>
<li>Understanding how <code>mill.example.ExampleTestSuite</code> works.
<ul>
<li>See that in <code>local</code> mode it invokes the mill launcher produced by <code>dev.launcher</code> repeatedly. (which invokes the <code>mill.main.client.MillClientMain</code> class)</li>
<li><code>mill.runner.MillServerMain</code> gets started by MillClientMain, before running the main of <code>mill.runner.MillMain</code></li>
</ul>
</li>
<li>Looking at <code>MillBuildBootstrap</code>
<ul>
<li>Found the part where Mill parses build.sc files.</li>
</ul>
</li>
<li>Try to build the <code>dev.runner</code> target by changing <code>scalaVersion</code> to <code>3.5.0-RC6</code>.</li>
<li>First update the tasks in the <code>bridge</code> cross module to resolve the dotty sbt-bridge module.</li>
<li>Edits to <code>main.api</code> module:
<ul>
<li>Had to fix some extension method problem with Array.map</li>
<li>Manually define Mirror for JarManifest (to derive upickle RW) because it isn‚Äôt a case class.</li>
<li>Agg had some new problems automatically mixing-in collect and zipWithIndex, so they are overridden manually. Also ++ is final so override in Agg is removed</li>
</ul>
</li>
<li>Edits to <code>main.util</code> module:
<ul>
<li>Use 2.13 binary suffix in coursier dep</li>
<li>Fix extension method issue with coursier.ResolutionExtensions</li>
</ul>
</li>
<li>Edits to <code>main.define</code> module:
<ul>
<li>Remove <code>mill-moduledefs</code> plugin temporarily - will be necessary later to support <code>override</code> insertion.</li>
<li>Don‚Äôt include <code>scala-reflect</code> on classpath</li>
<li>Use 2.13 binary suffix in jarjarabrams dep</li>
<li>Comment out macros definitions in <code>Task.scala</code></li>
</ul>
</li>
</ul>
<h3><a href="#2024-aug-06" id="2024-aug-06" class="anchor-link anchor-link__source"><i class="fa-solid fa-link"></i></a>2024-aug-06</h3>
<ul>
<li>Edits to <code>main.define</code> module:
<ul>
<li>(identified fastparse usage in <code>Reflect.scala</code>)</li>
<li>Comment out macros in <code>Discover.scala</code></li>
<li>Comment out macros in <code>Applicative.scala</code></li>
<li>Copy implementation of <code>mill.moduledefs.Cacher</code> for <code>Module.BaseClass</code>.</li>
<li>Comment out macro of <code>Caller.scala</code></li>
<li>Comment out Factory macro in <code>Cross.scala</code></li>
<li>Comment out macro of <code>EnclosingClass.scala</code></li>
<li>Comment out macro impl in <code>Task.scala</code></li>
</ul>
</li>
<li>Edits to <code>main.eval</code> module:
<ul>
<li>Change syntax of explicit context parameter passing</li>
</ul>
</li>
<li>Edits to <code>main.resolve</code> module:
<ul>
<li>Change syntax of explicit context parameter passing</li>
<li>(identified fastparse usage in <code>ExpandBraces.scala</code>)</li>
<li>(identified fastparse usage in <code>ParseArgs.scala</code>)</li>
<li>Change syntax of pattern matching for comprehension</li>
</ul>
</li>
<li>Edits to <code>main</code> module
<ul>
<li>Remove scala-reflect from compile classpath</li>
<li>Copy implementation of <code>mill.moduledefs.Scaladoc</code> for <code>MainModule.scala</code>.</li>
<li>Make <code>Target.log</code> inline (in <code>main.define</code>) so that it drops the ctx argument (avoiding compiletimeonly errors)</li>
<li>Make <code>Applyer.ctx()</code> inline (in <code>main.define</code>) so that it drops the ctx argument (avoiding compiletimeonly errors)</li>
<li>Make <code>Applyable.apply()</code> inline (in <code>main.define</code>) so that it drops the handler argument (avoiding compiletimeonly errors)</li>
<li>Temporarily remove ctx argument from <code>ClassLoader.create</code> in (in <code>main.api</code>)</li>
</ul>
</li>
<li>Edits to <code>scalalib</code> module:
<ul>
<li>Use 2.13 binary suffix on <code>scalafmt-dynamic</code> dep</li>
<li>Temporarily add <code>@mainargs.main</code> annotation to <code>IvyDepsTreeArgs</code> so compilation continues - opened <a href="https://github.com/com-lihaoyi/mainargs/issues/143">https://github.com/com-lihaoyi/mainargs/issues/143</a> to track problem</li>
<li>Fix syntax of lambda parameters</li>
<li>Reimplement <code>scala.tools.nsc.io.Streamable.bytes</code></li>
<li>Generate Mirrors for types in <code>JsonFormatters.scala</code></li>
<li>(identified fastparse usage in <code>VersionParser.scala</code>)</li>
<li>Comment out majority of <code>PublishModule.scala</code></li>
</ul>
</li>
<li>Now I am seeing that <code>Task</code> is pretty much everywhere at this point, and too much to comment away/remove <code>Ctx</code> from signatures, so likely not going to progress much without implementing it properly.
<ul>
<li>Remove any <code>compileTimeOnly</code> annotations (for now)</li>
<li>Restore signatures of <code>ctx</code> accessors in <code>Tasks.scala</code>, and <code>Applicative.scala</code>, and restore <code>ClassLoader.create</code>.</li>
<li>Restore all code in  <code>PublishModule.scala</code></li>
<li>Add import to help derive RW for <code>PublishData</code>.</li>
</ul>
</li>
<li>Edits to <code>scalalib.worker</code> module:
<ul>
<li>Change classpath of zinc module and scalap</li>
</ul>
</li>
<li>Edits to <code>scalajslib</code> module:
<ul>
<li>Generate Mirrors for classes and objects in <code>ScalaJSApi.scala</code> and <code>Report.scala</code></li>
</ul>
</li>
<li>Edits to <code>bsp</code> module:
<ul>
<li>Generate mirrors for <code>BspServerResult</code></li>
</ul>
</li>
<li>Edits to <code>codesig</code> module
<ul>
<li>Fix syntax and type inference</li>
</ul>
</li>
<li>Edits to <code>runner</code> module
<ul>
<li>Temporarily remove <code>linenumbers</code> dependency</li>
<li>Fix lambda syntax</li>
<li>Fix explicit context bound passing</li>
<li>(identified fastparse usage in <code>Parsers.scala</code>)</li>
<li>Temporarily disable mainarg parsing for <code>MillCliConfig</code>. (because of a crash caused by a type mismatch in default parameters)</li>
</ul>
</li>
<li>Edits to <code>dev</code> module:
<ul>
<li>Comment out some contrib deps not necessary to run example.basic test suite,</li>
<li>(also some minor fixes to classpath of contrib.bloop, and syntax of contrib.buildInfo)</li>
</ul>
</li>
<li>Now I can run <code>example.basic[1-simple].local</code> but it fails due to all the <code>???</code> I added in.
<ul>
<li>Primarily the <code>MillCliConfig</code> mainargs parser - so we can work backwards from this.</li>
</ul>
</li>
</ul>
<h3><a href="#2024-aug-07" id="2024-aug-07" class="anchor-link anchor-link__source"><i class="fa-solid fa-link"></i></a>2024-aug-07</h3>
<ul>
<li>I cloned a local version of mainargs to try and debug the problem in <code>MillCliConfig</code>.
<ul>
<li>First I tried to print the actual types of the arguments that were mismatched, it turned out I got a <code>Leftover[String]</code> when <code>Flag</code> was expected.</li>
<li>Then i printed the parameters of the apply method that was selected, it turned out it was the overloaded ‚Äúshim‚Äù apply method.</li>
<li>So I published locally a fix to mainargs to select the apply method where the names of parameters match the class constructor. (in reality perhaps we should invent a new annotation to deterministically declare which method to pick for the class parser?)</li>
<li>Also took the opportunity to create a default main annotation if none was found. So i removed main annotations from <code>MillCliConfig</code> and from <code>IvyDepsTreeArgs</code></li>
</ul>
</li>
<li>With the locally published mainargs, i updated the mill build to use it, and could revert any changes made previously and the build worked.</li>
<li>Now the next unimplemented error in <code>example.basic[1-simple].local</code> is the <code>Discover</code> macro.</li>
<li>Edits to the <code>main.define</code> module:
<ul>
<li>I implement the <code>Discover</code> macro, it seems to be mostly portable exactly as before - i notice however it does a funny thing - it imports all the given <code>TokenReaders</code> from the <code>main</code> module, which is not possible to do in quotes because they must be well typed at definition.</li>
<li>When i run the discover macro on <code>RootModule.Foreign</code> it crashes because for some reason the typeMembers returned by dotty includes the NoSymbol, so i had to explicitly filter that out - however that should be a bug in dotty.</li>
<li>Next error - there is an ‚Äúreference to parameter <code>b</code> was used outside its scope in inlining phase‚Äù, which is an internal dotty error so i can‚Äôt catch it in the macro. By searching for <code>b:</code> In both mill and mainargs, i found that <code>b</code> is the parameter of a quoted lambda in the <code>mainargs</code> library - because I renamed it to <code>bSpooky</code> and the error message changed accordingly.</li>
<li>Turns out it was solved by swapping the type arguments of createMainData,</li>
<li>Now the problem is that mainargs does not do varargs adaption - e.g. <code>MainModule.clean</code></li>
<li>Implement in mainargs the varargs adaption trick copied from upickle.</li>
<li>Next I saw that the default argument parsing for mainargs was again incorrect when there are several overloaded commands. I ignore defaults in mainargs when the method has no defaults by checking for the flag HasDefaults.</li>
<li>Now there is one last discovery error: ‚Äú<code>invalid new prefix = JavaModule.this.JavaModuleTests cannot replace (JavaModule.this : mill.scalalib.JavaModule) in type JavaModule.this.JavaModuleTests</code>‚Äù not sure where this comes from, will need investigation. - The problem was to do with path dependent types - mainargs isn‚Äôt resolving default accessors properly, because it needs a prefix to select from.</li>
</ul>
</li>
</ul>
<h3><a href="#2024-aug-08" id="2024-aug-08" class="anchor-link anchor-link__source"><i class="fa-solid fa-link"></i></a>2024-aug-08</h3>
<ul>
<li>Edits to the <code>main.define</code> module:
<ul>
<li>I filter out synthetic methods in the discover macro, (i found that a superaccessor was being generated as a command - due to an override)</li>
<li>also switch to only scanning module values in Discover.</li>
<li>In lieu of fixing mainargs, i manually created a Discover instance with code gen for <code>MillBuildBootstrap (MillBuildRootModule.BootstrapModule)</code> - which was a pain.</li>
<li>I fixed mainargs to select the default getter from the lambda parameter, which means it works for non-static getters. So i deleted the manual discover instance, and could restore any commented out Discover macro callsites.</li>
<li>Now all <code>Discover</code> macro call sites are building (perhaps implementation is still not 1:1 with scala 2? Needs more testing)</li>
<li>Now the next <code>unimplementedError</code> problem in the <code>example.basic[1-simple].local</code> test is <code>Caller</code> macro.</li>
</ul>
</li>
</ul>
<h3><a href="#2024-aug-09" id="2024-aug-09" class="anchor-link anchor-link__source"><i class="fa-solid fa-link"></i></a>2024-aug-09</h3>
<p>Trying to implement the caller macro - it seems not possible to implement correctly in extends clauses - so i opened <a href="https://github.com/scala/scala3/issues/21358">https://github.com/scala/scala3/issues/21358</a> - perhaps we should have 2 subclasses of <code>Caller</code> so one is for methods (where enclosing class is correct), and one for extends clauses (where we need to get the class outside the current class) - waiting on comment from Haoyi</p>
<ul>
<li>Based on comment - i remove the <code>Caller.generate</code> macro, instead define an implicit within Module that returns itself - this will perform the equivalent as the macro</li>
<li>Now next unimplementedError in <code>example.basic[1-simple].local</code> is <code>Target.apply</code></li>
</ul>
<h3><a href="#2024-aug-12" id="2024-aug-12" class="anchor-link anchor-link__source"><i class="fa-solid fa-link"></i></a>2024-aug-12</h3>
<ul>
<li>Attempting to fix the Target.apply macro - for now i construct the TargetImpl object with placeholder values - now Applicative <code>defaultApplyHandler</code> (previously compiletimeonly) is being reached, so we do need to implement the <code>Target.apply</code> macro to eliminate this.</li>
<li>Start implementing Task.apply (implicit conversion macro) - and implement detection of if target owner is private - but now i need two other macro definitions - Cacher.impl0 and Applicative.impl0</li>
<li>Implemented Applicative macro - needed to manually pass in the caller rather than <code>c.internal.prefix</code> - this isn‚Äôt part of quoted api. Also I needed to add more precise types to help with actually typing the inner expression.</li>
<li>This lead to the <code>Target.task</code> macro being next to fail, so I implemented that, followed by <code>Target.sources</code> (<code>sourcesImpl2</code>), followed by <code>Target.inputs</code> and finally <code>Target.sources</code> (<code>sourcesImpl1</code>).</li>
<li>Now at this point i get to <code>MillBuildRootModule.lineNumberPluginClasspath</code> in the example test, and it tries to evaluate <code>defaultApplyHandler</code> - so either this macro wasnt handled yet, or there is a bug in the macro to not eliminate it. However it seems to just be <code>Task.apply</code> (with result input) is not implemented.</li>
<li>Next <code>defaultApplyHandler</code> is from ScalaModule.compile - which is the unimplemented <code>T.persistent</code> macro</li>
<li>Next was failing the <code>Target.worker</code>.</li>
<li>Then <code>Target.apply</code> (of a Task)</li>
<li>Next only errors were to fix the <code>???</code> in coursier module, but now i have a test failure that isn‚Äôt to do with unimplementedError - so will need to debug that. But for now i will focus on restoring compileTimeOnly annotations to be sure rewrites are correct.</li>
<li>Now implementing all remaining Target macros</li>
<li>Determined that the fault is due to the default classpath of the mill bootstrap module - will have to enable more debugging info so i can see exactly what isn‚Äôt resolved.</li>
</ul>
<h3><a href="#2024-aug-13" id="2024-aug-13" class="anchor-link anchor-link__source"><i class="fa-solid fa-link"></i></a>2024-aug-13</h3>
<ul>
<li>Classpath resolution is failing in an opaque manor, because it is just throwing an exception inside a task - so I added a new <code>resolveDeps0</code> method to the <code>CoursierModule.Resolver</code> that returns its resolution as a <code>Result</code>, this means we can propagate resolution errors correctly to the <code>ScalaModule.scalaCompilerClasspath</code> task.</li>
<li>Identifying the missing dependencies as some compiler plugins so need to remove those temporarily.</li>
<li>Then ZincWorkerImpl was having issues resolving <code>scala-library</code> from the compiler classpath when building the <code>mill-build</code> task - which is correct as the resolution of the <code>Lib.scalaRuntimeIvyDeps</code> deps was excluding <code>scala-library</code> - which i discovered by printing the deps before resolution. This exclusion comes from <code>MillBuildRootModule.resolveDepsExclusions</code> as it is part of the classpath of mill itself - so i made an exception to excluding the scala-library for the mill root build - perhaps there is a better and localised solution?</li>
<li>Next i discovered in running example test that the generated script file discover macro needed explicit TokenReader imports so added that.</li>
<li>Now i can actually run many integration tests out of the box - e.g. <code>example.tasks[1-task-graph].local</code>. - i am still relying on my locally published mainargs however - so should quickly submit some PR for that to be released.</li>
<li>With some integration tests passing locally I opened a <a href="https://github.com/com-lihaoyi/mill/pull/3369">PR to Mill</a></li>
<li>Some features which are necessary to pass more integration tests are
<ul>
<li><code>mill-moduledefs</code> compiler plugin to infer override keywords, and insert annotations that record scaladoc comments. (although we can access the scaladoc of a method via macros? - it seems java reflection resolves this info in the task but maybe we could redesign)</li>
<li><code>mill-runner-linenumbers</code> compiler plugin to fix line numbers of trees (is this even allowed in dotty?)</li>
</ul>
</li>
<li>Got encouragement to open a mainargs PR to add my fixes - so then prepared my changes for a PR - while adding restoring unit tests for vararg handling, i noted that the parsing at runtime was actually incorrect - so what was needed is to copy the Scala 2 implementation - convert the parameter type from <code>T*</code> to <code>Leftover[T]</code> to create the <code>ArgSig</code>. Then at the callsite you still need a vararg value, but the argument will need to be converted from <code>Leftover[T]</code> back to <code>T*</code>. I will add unit tests for the path dependent type handling of default args, Classparser for classes without <code>@main</code>, and the overloaded apply method in companion for classparser.</li>
</ul>
<h3><a href="#2024-aug-14" id="2024-aug-14" class="anchor-link anchor-link__source"><i class="fa-solid fa-link"></i></a>2024-aug-14</h3>
<ul>
<li>Spent the day adding unit tests to mainargs to prepare for a pull request, <a href="https://github.com/com-lihaoyi/mainargs/pull/148">opening it</a> at the end of the day.</li>
<li>Also forked the mill-moduledefs repo, fixed the build.sc to set up cross building both library and compiler plugin for scala 2.13 and 3.5.0.</li>
</ul>
<h3><a href="#2024-aug-16" id="2024-aug-16" class="anchor-link anchor-link__source"><i class="fa-solid fa-link"></i></a>2024-aug-16</h3>
<ul>
<li><a href="https://github.com/com-lihaoyi/mainargs/pull/148">Mainargs PR</a> was merged, released in version 0.7.2. I updated my <a href="https://github.com/com-lihaoyi/mill/pull/3369">Mill PR</a> to include the new dependency and GitHub actions CI now records several integration tests passing, such as <code>example.tasks[6-workers].local</code></li>
</ul>
<h3><a href="#2024-aug-20" id="2024-aug-20" class="anchor-link anchor-link__source"><i class="fa-solid fa-link"></i></a>2024-aug-20</h3>
<ul>
<li>Implemented the <code>EnableScaladocAnnotation</code> phase in the mill-moduledefs compiler plugin. It‚Äôs greatly simplified from scala 2 as dotty makes it easy to access documentation for symbols, and Its easier to create annotations. I had to make some tweaks - adjust <code>runsAfter</code> to be <code>‚Äùposttyper‚Äù</code> rather than <code>‚Äùparser‚Äù</code> (standard plugin must be after typer). Also I had to adjust <code>build.sc</code> again to hardcode the artifact name due to the outer module now being a cross module.</li>
</ul>
<h3><a href="#2024-aug-21" id="2024-aug-21" class="anchor-link anchor-link__source"><i class="fa-solid fa-link"></i></a>2024-aug-21</h3>
<ul>
<li>Implemented the <code>AutoOverride</code> phase in mill-moduledefs, now the plugin is finished - opened a <a href="https://github.com/com-lihaoyi/mill-moduledefs/pull/14">PR</a> after some cleanups.</li>
<li>Fixed the <code>millProjectModule</code> to have <code>_3</code> suffix by default - now all of example.basic integration tests are passing except <code>4-builtin-commands</code> - for some reason the <code>showUpdates</code> command is failing - upon investigation - it seems that it is overloaded, and the <code>Discover</code> macro picks the wrong one (i.e. the deprecated one with no default arguments) - will need to fix this.</li>
<li>Went with the fix of filtering out deprecated methods in the Discover macro, which fixed the test. Now all <code>example.basic</code> tests are passing locally. Next for integration tests would be the <code>Cross</code> macro.</li>
<li>Next I discovered that my patch to build scripts to include the empty package prefix was wrong - multi build roots now mean that there can be nested packages in the prefix - so I adjusted the code generation there - now passing all of <code>example.misc</code> tests.</li>
</ul>
<h3><a href="#2024-aug-22" id="2024-aug-22" class="anchor-link anchor-link__source"><i class="fa-solid fa-link"></i></a>2024-aug-22</h3>
<ul>
<li><a href="https://github.com/com-lihaoyi/mill-moduledefs/pull/14">mill-moduledefs PR</a> was merged, changes released in 0.11.0-M1. I rebased my Mill PR, which revealed another type inference issue (solved with an explicit type).</li>
</ul>
<h3><a href="#2024-aug-23" id="2024-aug-23" class="anchor-link anchor-link__source"><i class="fa-solid fa-link"></i></a>2024-aug-23</h3>
<ul>
<li>Began work on <code>Cross.Factory</code> macro. I realised I could not proceed without using the experimental methods <code>Symbol.newClass</code> and <code>ClassDef.apply</code>. Moreover, these methods are not adequate because they do not allow to customise the primary constructor, which was necessary to add the Context parameter. I knew I would have to rely upon compiler internals - so I decided to implement a Shim interface in the <code>mill-moduledefs</code> library, with an implementation provided by the <code>scalac-mill-moduledefs-plugin</code> library. I tried this and realised that the plugin library isn‚Äôt on the classpath when loading macros, so this didn‚Äôt work.</li>
<li>I asked the Discord channel for advice and Haoyi said it would be permissible to use compiler internals even in the <code>main.define</code> module.</li>
</ul>
<h3><a href="#2024-aug-27" id="2024-aug-27" class="anchor-link anchor-link__source"><i class="fa-solid fa-link"></i></a>2024-aug-27</h3>
<ul>
<li>I implemented the Shims inside <code>main.define</code> module and finished the <code>Cross.Factory</code> macro</li>
</ul>
<h3><a href="#2024-sep-04" id="2024-sep-04" class="anchor-link anchor-link__source"><i class="fa-solid fa-link"></i></a>2024-sep-04</h3>
<ul>
<li>Cleaned the code and pushed my changes to implement the <code>Cross.Factory</code> macro.</li>
</ul>
<h3><a href="#2024-sep-06" id="2024-sep-06" class="anchor-link anchor-link__source"><i class="fa-solid fa-link"></i></a>2024-sep-06</h3>
<ul>
<li>Investigated and fixed two problems related to the <code>Discover</code> macro:
<ul>
<li>A. not scanning correctly the type argument of a cross module</li>
<li>The scala 2 method of an immediately invoked closure (to split bytecode into manageable size) was optimised away, so the large-project integration test was failing - changing this to an explicit def avoids the optimisation, so the test works again.</li>
</ul>
</li>
<li>At this point - it would seem most test failures are now due to misconfiguration of classpath dependencies. I need to investigate the <code>linenumbers</code> compiler plugin, before I can attempt to support new scala 3 syntax.</li>
</ul>
<h3><a href="#2024-sep-09" id="2024-sep-09" class="anchor-link anchor-link__source"><i class="fa-solid fa-link"></i></a>2024-sep-09</h3>
<ul>
<li>Decided to try porting <code>linenumbers</code> compiler plugin, or find an alternative.</li>
<li>Dotty will not allow a plugin to mutate source positions before type checking. Therefore we should modify positions via the reporter.
<ul>
<li>There are two reporters: one in the BSP module, and one in the zinc worker. We need to share where possible the logic to fix positions.</li>
</ul>
</li>
<li>I copied some logic from the <code>LineNumberPlugin</code> to the <code>ZincWorkerImpl</code> (identify build files) - still need to compute the updated positions. There is a bit of help already via the <code>ManagedLoggedReporter</code> which accepts a function argument to remap positions.</li>
</ul>
<h3><a href="#2024-sep-10" id="2024-sep-10" class="anchor-link anchor-link__source"><i class="fa-solid fa-link"></i></a>2024-sep-10</h3>
<ul>
<li>Worked on rendering the correct positions for the reporter in <code>ZincWorkerImpl</code>, and also replicating the style of the console error reporter from dotty. (Still remains to share/copy the logic in the BSP module‚Äôs reporter)</li>
</ul>
<h3><a href="#2024-sep-11" id="2024-sep-11" class="anchor-link anchor-link__source"><i class="fa-solid fa-link"></i></a>2024-sep-11</h3>
<ul>
<li>Fixed remaining <code>integration.failure</code> tests that check compiler error messages (note: line number, column, and ‚Äúkind‚Äù of error were unchanged, but other elements of messages were compiler specific)</li>
<li>Moved <code>integration.failure[things-outside-top-level-module]</code> to <code>integration.feature</code> to account for the fact that top-level definitions are generally allowed in Scala 3 (after approval from Haoyi).</li>
<li>Moving on, it seems that the CodeSig checker is incorrect (<code>integration.invalidation[codesig-hello]</code> fails)</li>
<li>Fixed compilation issues in the unit tests for codesig <code>main.codesig.test</code>. - Now I can identify that at least 1 method hash test fails, and three call graph tests.</li>
<li>I analysed the byte code of the failing method hash test, and I see that the failing method fails due to changing the line where <code>sourcecode.Line</code> is summoned. So my assumption is that something changed between scala 2 and 3. I then compared bytecode outputs of the programs when compiled by Scala 2 or 3. In scala 2 the macro generates <code>new Line(n)</code> but in Scala 3 it is <code>Line.apply(n)</code>. I then went to the PR for adding CodeSig, and i see a footnote that the ‚Äúnew Line‚Äù pattern is special cased - so that will need to be fixed (either in sourcecode, or in CodeSig)</li>
<li>Fixing the special casing did help with the methodhash test, but the callgraph tests are still failing. In particular - for <code>basic.18-scala-anon-class-lambda</code>,<code>complicated.8-linked-list-scala</code>,<code>realistic.4-actors</code>, <code>realistic.5-parser</code>,</li>
<li>The problems with <code>8-linked-list-scala</code> and <code>4-actors</code> were caused by changes in inference semantics for private fields, and for overridden methods (which i fixed by updating the code of the test, rather than Codesig implementation). The <code>5-parser</code> test will be much harder to validate as the internals of fastparse‚Äôs macro changed - I might just have to copy the new result and identify any  regression when fixing other tests.</li>
</ul>
<h3><a href="#2024-sep-12" id="2024-sep-12" class="anchor-link anchor-link__source"><i class="fa-solid fa-link"></i></a>2024-sep-12</h3>
<ul>
<li>I determined that the problem with <code>18-scala-anon-class-lambda</code> is that its bytecode was dependent on how scala 3 does specialisation, so i replaced it and <code>17-scala-lambda</code> with a similar SAM that isn‚Äôt specialised.</li>
<li>Then i changed <code>5-parser</code> as i assumed, and it was only additions, no changes of other methods, so i believe it is safe. So now all <code>main.codesig.test</code> unit tests were passing - not explaining the problem in the integration tests.</li>
<li>Then I updated dependencies for scalatags and scalaj-http, to enable invalidation tests to run. By enabling some verbose logging i saw that for <code>[codesig-hello]</code> the class was recompiled after changing the implementation. So then I decided to compare the bytecode of compiling the build.mill file in scala 2 vs 3. It seems scala 3 has a different naming convention for lambda functions, which I will investigate as the cause of not tracking the changes.</li>
</ul>
<h3><a href="#2024-sep-13" id="2024-sep-13" class="anchor-link anchor-link__source"><i class="fa-solid fa-link"></i></a>2024-sep-13</h3>
<ul>
<li>Investigating the causes for <code>[codesig-hello]</code> to fail, I then run the same test on the <code>main</code> branch (i.e. with Scala 2 implementation) - with debugging turned on, i can compare the outputs of the <code>methodCodeHashSignatures.dest</code> in the failing part (i.e. changing the body of <code>foo</code> had no effect). I saw that in <code>prettyCallGraph.json</code> that for some reason there is no call recorded to the no-arg lambda implementation of foo (which gets passed to Cacher), when there was in Scala 2 implementation. Eventually i checked the ignoreCalls filter in <code>MillBuildBootstrapModule</code> and it was clear that the lambda function was ignored because it was treated as a ‚Äúsimple target‚Äù because it has no-args. This is a consequence of the lambda encoding of scala 3, which uses instance methods, not static ones. So i taught the filter to look for lambda methods and it passes the test. Next was failing <code>[codesig-scalamodule]</code>. Originally i could see output was including extra warnings due to indentation changes caused by inserting newlines as part of the test. So i corrected the indentation. The test still failed due to the old version of <code>sourcecode</code> being on the classpath when compiling the build.mill file. I fixed this with an explicit dependency on sourcecode in the main.define module - I should check which module first depends on it. Now all codesig tests were passing.</li>
</ul>
<h3><a href="#2024-sep-14" id="2024-sep-14" class="anchor-link anchor-link__source"><i class="fa-solid fa-link"></i></a>2024-sep-14</h3>
<ul>
<li>To fix <code>integration.invalidation[multi-level-editing].local</code>, i noticed that the meta-build dependency on scalatags was bringing in a conflicting scala 2 version of sourcecode, preventing the build.mill file from compiling. I instead changed to a scala 3 version in the metabuild, and updated the scalatags dependency</li>
<li>I then re-enabled publishing of test deps for the playlib and scoverage contrib modules, fixing a few more tests</li>
<li>I toyed around with fixing <code>integration.feature[plugin-classpath].local</code>, but this seems harder to fix. Essentially the plugin brings in a conflicting old dependency of mill (i.e. with scala 2 binary version). Either i have to exclude the dependency and hope nothing breaks, or build the metabuild with a suitable scala 2 version. I parked this for now.</li>
</ul>
<h3><a href="#2024-sep-15" id="2024-sep-15" class="anchor-link anchor-link__source"><i class="fa-solid fa-link"></i></a>2024-sep-15</h3>
<ul>
<li>To fix <code>integration.ide[gen-idea].local</code>, I had to fix some xml generation code which relied upon implicit conversions that no longer work in Scala 3. I also had to update some checkfiles to account for the updated versions.</li>
<li>I enabled all contrib test module dependencies, fixing necessary compile errors.</li>
<li>Next, i fixed the <code>integration.feature[init].local</code> test by updating the classpath of the Giter8 module in scalalib. I noticed that a dependency resolution error was not being reported so i ensure that it does.</li>
<li>I also removed the deadcode linenumbers module.</li>
</ul>
<h3><a href="#2024-sep-16" id="2024-sep-16" class="anchor-link anchor-link__source"><i class="fa-solid fa-link"></i></a>2024-sep-16</h3>
<ul>
<li>Rebased the PR against Main, in which I had to tweak <code>CodeGen</code> to account for the new structuring of json formatters and TokenReaders.</li>
<li><code>CodeGen</code> also had to be tweaked to generate the Discover value in the same wrapper object as the user code. If not, then path dependent types would not match when trying to summon <code>mainargs.TokenReaders[Foo]</code> if <code>Foo</code> was a custom type. This meant having to merge all the Discover values from child modules (from <code>package.mill</code> files), and also substituting <code>classOf[package_]</code> for <code>classOf[package_.type]</code> in the map.</li>
<li>^ it might be possible in <code>mainargs</code> to substitute the prefix of the caller when summoning <code>TokenReaders</code> which would make this ‚Äúhack‚Äù unnecessary, but it is unverified if it could work.</li>
<li>I also reimplemented the <code>contrib.scoverage.api</code> module to be java based, so it didn‚Äôt matter if the scala version was not compatible with the underlying scoverage library API.</li>
</ul>
<h3><a href="#2024-sep-17" id="2024-sep-17" class="anchor-link anchor-link__source"><i class="fa-solid fa-link"></i></a>2024-sep-17</h3>
<ul>
<li>Skipped the test <code>integration.feature[plugin-classpath].local</code> as it depends on a third party Mill plugin, not binary compatible with the scala 3 version of mill</li>
</ul>
<h3><a href="#2024-sep-19" id="2024-sep-19" class="anchor-link anchor-link__source"><i class="fa-solid fa-link"></i></a>2024-sep-19</h3>
<ul>
<li>Fix classpath resolution problems with contrib twirllib and contrib playlib</li>
</ul>
<h3><a href="#2024-sep-20" id="2024-sep-20" class="anchor-link anchor-link__source"><i class="fa-solid fa-link"></i></a>2024-sep-20</h3>
<ul>
<li>Fix warnings about <code>scala.AnyKind</code> in the <code>contrib.proguard</code> tests</li>
<li>Remove a test source from being compiled in <code>example.thirdparty[3-mockito].local</code> because it often failed in the CI (and it isn‚Äôt a necessary test to prove mill can substitute as the build tool)</li>
<li>Fix contrib.scoverage integration test</li>
<li>Filtered a problematic file from scalafmt checks (due to outdated scalafmt dependency)</li>
<li>Skipped checking scalafix in scala 3 sources, because the scalafix-interfaces library does not support reflectively loading the scala 3 scalafix library.</li>
<li>Patched Mima checks to correctly load the previous jar (accounting for platform suffix changes)</li>
<li>Then skipped the mima checks because there were 1000s of (expected) errors.</li>
<li>Patched any remaining failures due to not reformatting with scalafmt</li>
<li>Generated a patch file so that the <code>ci/test-mill-bootstrap.sh</code> test passed.</li>
<li>Managed to pass all tests in the CI on the PR #3369</li>
</ul>
<h3><a href="#2024-sep-21" id="2024-sep-21" class="anchor-link anchor-link__source"><i class="fa-solid fa-link"></i></a>2024-sep-21</h3>
<ul>
<li>Created initial <code>integration.feature[scala-3-syntax]</code> test, which failed due to fastparse‚Äôs ‚Äúscalaparse‚Äù being inadequate.</li>
<li>Fixed a problem with the new Zinc error formatter which broke ansi escape codes.</li>
<li>Experimented with reimplementing scalaparse from dotty‚Äôs grammar, but it was taking too long.</li>
<li>Investigated scalameta as a possible parser. Haoyi preferred to reuse dotty‚Äôs parser to reduce dependencies, it was also decided to only support the same version as mill is built with.</li>
</ul>
<h3><a href="#2024-sep-23" id="2024-sep-23" class="anchor-link anchor-link__source"><i class="fa-solid fa-link"></i></a>2024-sep-23</h3>
<ul>
<li>I abstracted the necessary parsing operations <code>splitScript</code> and <code>parseImportHooksWithIndices</code> into a trait, in a new <code>runner.worker-api</code> module. The existing <code>runner.Parsers</code> object implements the trait for Scala 2, and the Scala 3 implementation was stubbed in a <code>runner.worker</code> module, which an instance for should be loaded via reflection.</li>
<li>Next I abstracted the <code>FileImportGraph.parseBuildFiles</code> method over the new parser trait, which is called in <code>MillBuildBootstrap</code> (i.e. before we load <code>MillBuildRootModule</code>). This posed a challenge for how to resolve and load the <code>mill-runner-worker</code> library reflectively.</li>
<li>I implemented the steps to load a worker instance are as follows:
<ul>
<li>Resolve in <code>MillMain</code> the dependencies <code>mill-runner-worker</code> and <code>scala3-compiler</code> to a classpath and reflectively load the runner.</li>
<li>Pass the worker and resolved classpath to <code>MillBuildRootModule.BootstrapModule</code> which then re-uses it in its own <code>parseBuildFiles</code> task.</li>
<li>The pre-computed worker classpath is then used in <code>generateScriptSources</code> to write the classpath to the generated <code>MillMiscInfo</code> which can then resolve the worker the next time the class is loaded.</li>
</ul>
</li>
</ul>
<h3><a href="#2024-sep-24" id="2024-sep-24" class="anchor-link anchor-link__source"><i class="fa-solid fa-link"></i></a>2024-sep-24</h3>
<ul>
<li>I implemented the first part of scriptSplitting - setting up the compiler to run only the parser phase, and report any errors - I implemented my own error formatting, as I wasn't sure if I would need to manipulate positions again.</li>
<li>I also tweaked the SkipScalafix Mill module so it can call the super.fix (by moving scala version from a task to a method)</li>
<li>I then realised it wasn‚Äôt necessary to run the proper compiler pipeline, I could initialise a context with a source file and reporter, then create an outline parser directly. I then traversed the output to extract the top-level packages, and top level statement strings by creating slices of the source file content for the span of each statement, and slices of the whitespace in between.</li>
</ul>
<h3><a href="#2024-sep-25" id="2024-sep-25" class="anchor-link anchor-link__source"><i class="fa-solid fa-link"></i></a>2024-sep-25</h3>
<ul>
<li>I noticed there was a long delay in loading the standard definitions, so I wanted to see if it was possible to cache the initial context loading. I discovered by re-running split script 10000 times concurrently with futures that parsing had to be synchronized, but it was safe to share the same initial context</li>
<li>I then discovered that actually the standard definitions did not need to be initialised before parsing, so this saved another initial load time.</li>
<li>Implement import parsing - i had to fix a mistake in script splitting, because in dotty comma-separated imports are treated as separate statements. However they are not able to be parsed standalone from text, so I had to pack them all together as one statement</li>
<li>Implemented top-level object scanning (compatible with scala 2), however i needed to extract more information to be compatible with Scala 3 - a possible end marker (for renaming <code>`package`</code> to <code>package_</code>), and also the problem with path-dependent types in the discover macro also needed to be applied to when the user provides an explicit top level object. This means i had to extract a suitable position to splice in code within the user code (i.e. within an object), so i extracted the position of the initial statement</li>
</ul>
<h3><a href="#2024-sep-26" id="2024-sep-26" class="anchor-link anchor-link__source"><i class="fa-solid fa-link"></i></a>2024-sep-26</h3>
<ul>
<li>Back to top-level object scanning, I realised that splicing at the top of user code would require more hacking with positions in the reporter, so I changed to extract the position of the final statement instead.</li>
<li>Then I rebased against main, and refactored my scala 3 parsing code to remove leftovers from implementing.</li>
<li>When running the <code>ci/test-mill-bootstrap.sh</code> test, it crashed when parsing the build with the new parser - this was due to not escaping EmptyTree from the outline object parser (if it turns out that it causes more pain then needed, we can revert to the regular parser) - i fixed the broken <code>atSpan</code> method.</li>
<li>Pushed the scala 3 parser and syntax test to the main PR</li>
<li>Next, cleanup and refactoring the new <code>runner.worker</code> module</li>
<li>Add <code>runner.worker.testDep</code> to <code>dist0</code>, making it available to integration test <code>local</code> modules</li>
<li>Recomputed the <code>ci/mill-bootstrap.patch</code> file</li>
<li>Noticed in the CI an error - mill files should allow expressions at the top-level - so i adjusted the parser to treat block statements as top-level statements.</li>
<li>I also noticed a crash caused by stray EmptyTree‚Äôs being returned in the parser, so escaped those</li>
</ul>
<h3><a href="#2024-sep-27" id="2024-sep-27" class="anchor-link anchor-link__source"><i class="fa-solid fa-link"></i></a>2024-sep-27</h3>
<ul>
<li>Noticed another parsing error in the CI - need to filter out EmptyTree returned by scanning ModuleDef bodies</li>
<li>Fixed another minor issue (include backticks in package names)</li>
<li>Then i noticed that parsing mill statements with blockStatSeq prevents access modifiers, so i changed to templateStatSeq, (and skipping self-defs)</li>
<li>Added some stronger checking of spans on trees to ensure they exist in the source code.</li>
<li>Fixed parsing of backticked object names</li>
<li>Fixed the column number of parser error messages emitted by dotty.</li>
<li>Fixed the <code>ZincWorkerImpl</code> reporter to account for user-written code that can appear after spliced <code>__innerMillDiscover</code> definitions.</li>
<li>Escaped more <code>EmptyTrees</code></li>
<li>Added a prelude to parser errors <code>s‚Äù${file} failed to parse:\n‚Äù</code></li>
<li>CI on PR is now green <a href="https://emojipedia.org/party-popper">üéâ</a></li>
<li>Validated that the BSP reporter forwards messages from the Zinc reporter, so no adjustment of positions was needed.</li>
</ul>
<h3><a href="#2024-oct-10" id="2024-oct-10" class="anchor-link anchor-link__source"><i class="fa-solid fa-link"></i></a>2024-oct-10</h3>
<ul>
<li>Rebased the <code>scala3-build-sc</code> against <code>com-lihaoyi:main</code>.</li>
<li>Added <code>case</code> modifier to objects in <code>KotlinJSModule</code> - this was new code, but without the modifier, we would need to generate Mirror objects as we did previously.</li>
<li>Adapt the <code>Applicative</code> macro.
Caller <code>this</code> trees are no longer always an <code>Applicative.Applyer</code>, so resolving <code>traverseCtx</code> is no longer static.
I made two reimplementations, first, resolve the method via quoted reflection API, and check the types manually.
This avoids boilerplate at call site, but maybe less elegant.
The second implementation passes a lambda that will construct the call to the right <code>traverseCtx</code> method, when provided with argument Exprs.
This second option requires more boilerplate at the call-site, but is more resilient to API changes.</li>
<li>fixed various type and syntax errors introduced by newer code added in the base branch.</li>
<li>Re-introduced the <code>millDiscover</code> method in <code>RootModule.SubFolder</code>, in the scala 3 code gen we need to explicitly generate discover in child modules, and merge in the main module.
If it is possible to substitute the correct prefix in <code>mainargs</code> library, e.g. for custom types, we can revert this change.</li>
<li>After pushing to CI, there is a new test failure that tests output of inspect command for Modules - new code which might behave differently in Scala 3.</li>
</ul>
<h3><a href="#2024-oct-12" id="2024-oct-12" class="anchor-link anchor-link__source"><i class="fa-solid fa-link"></i></a>2024-oct-12</h3>
<ul>
<li>Rebased again</li>
<li>Replaced the manually generated mirrors from <code>manual_mirror_gen.sc</code> with a new macro in <code>mill.api.Mirrors</code>.
<ul>
<li>User declares a single <code>Root[Foo]</code> given, which is generated by a macro.</li>
<li>Root stores all possible mirrors for subclasses of <code>Foo</code> (including itself).</li>
<li>It tries to be conservative in what it generates, so it doesn't generate mirrors for case class / case object.</li>
<li>another macro <code>Mirrors.autoMirror</code> can provide a given <code>Mirror.Of[T]</code>, as long as there is a given <code>Root[R]</code>,
and it can construct a proof that a mirror for <code>T</code> is contained in the root.</li>
</ul>
</li>
<li>The new macro saves a lot of boilerplate - i.e. only 1-2 lines per class hierarchy. (+ 1 line for imports)</li>
</ul>
<h3><a href="#2024-oct-13" id="2024-oct-13" class="anchor-link anchor-link__source"><i class="fa-solid fa-link"></i></a>2024-oct-13</h3>
<ul>
<li>Haoyi mentioned that the linenumber changes should be propagated to the backend, so I investigated reviving the compiler plugin to edit positions.</li>
<li>Plugins can only be installed after type checking, so we would need to keep the Zinc reporter changes,</li>
<li>However I did an initial implementation that followed the same transform as performed by the Zinc reporter.</li>
<li>Unfortunately, the linenumbers were still incorrect in the bytecode.</li>
<li>I investigated the Scala 3 compiler backend to see how line numbers are generated.
I saw that it is by looking at the line number of the offset in the position,
in the source file of <em>the current compilation unit</em>, rather than in the source file of the position.</li>
<li>This is a problem because when we remap the positions in the plugin, we change both the offset, and the source file, so the computation in backend is incorrect.</li>
<li>It's still possible to mitigate this without patching the compiler, i.e. we can collapse the position to be zero-length.
<ul>
<li>We have to do a two-stage transform: compute the line of the position in the original file,</li>
<li>then lookup the offset of the start of that line in the current source file.</li>
<li>this position will compute the right line number in the backend, however the reporter will render completely incorrect code.
So, the reporter must be patched to re-direct the offset to the right line in the original script file.</li>
</ul>
</li>
<li>The plugin would also have to patch line numbers computed by the <code>sourcecode.Line</code> macro,
and the name computed by the <code>sourcecode.FileName</code> macro,
due to the difference in how macro expansion positions are computed.</li>
</ul>
<h3><a href="#2024-oct-14" id="2024-oct-14" class="anchor-link anchor-link__source"><i class="fa-solid fa-link"></i></a>2024-oct-14</h3>
<ul>
<li>The linenumber transform in the plugin is lossy and complex, so I made a patch to the compiler
so the backend computes the line from the source file of the position.</li>
</ul>
</div><div class="container mb-2"><div class="row"><div class="col d-flex"></div><div class="col d-flex flex-row-reverse"><small class="float-end"><a href="/projects/unrolled-methods-scala3.html">Add method unrolling to Scala 3 <i class="fa-solid fa-angle-right"></i></a></small></div></div></div></article></div></div></div></div><footer class="mt-auto"><div class="footer-copyright text-center py-3"><small>¬© 2024 Jamie Thompson.<span class="text-muted"> Last published 29/Nov/2024</span></small></div></footer><script src="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/js/bootstrap.bundle.min.js" integrity="sha384-MrcW6ZMFYlzcLA8Nl+NtUVF0sA7MsXsP1UyJoMp4YLEuNSfAP+JcXn/tWtIaxVXM" crossorigin="anonymous"></script><script src="/static/js/nav-toc_50380f89e0ac8b1f7a353e494026d8dd.js" type="text/javascript"></script><script src="/static/js/sidebar-mobile_63c21c40d63ae89bd8880d2e1b3dc2c9.js" type="text/javascript"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.5.1/highlight.min.js" type="text/javascript"></script><script src="/static/js/hljs-scala3_868eb64187ff110dc72ccc6085774ee9.js" type="text/javascript"></script><script src="/static/js/hljs_a6372cedaa54e6ef1cd502062aef22a1.js" type="text/javascript"></script><script src="/static/js/katex-render_ea5696b3297f767be055588a9afda5ce.js" type="text/javascript"></script><script src="/static/js/admonition_70fb98d2c3c7311ff9783fd7412c7132.js" type="text/javascript"></script></body></html>