<!DOCTYPE html><html><head><meta charset="utf-8" /><meta name="Content-Type" content="text/html; charset=utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" /><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.0/css/bootstrap.css" /><link rel="stylesheet" href="/static/css/style_16e6c4b812281157c6db58e9728a270c.css" /><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.2/css/all.min.css" crossorigin="anonymous" /><title>Understanding Match Types in Scala 3 | bishabosha</title><meta name="description" content="What are Scala 3 match types for and how do they work." /><meta name="twitter:card" content="summary" /><meta name="twitter:title" content="Understanding Match Types in Scala 3 | bishabosha" /><meta name="twitter:site" content="@bishabosha" /><meta name="twitter:description" content="What are Scala 3 match types for and how do they work." /><meta name="og:title" content="Understanding Match Types in Scala 3 | bishabosha" /><meta name="og:description" content="What are Scala 3 match types for and how do they work." /><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.6.0/styles/default.min.css" /><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.9/katex.min.css" /><script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.9/katex.min.js" type="text/javascript"></script><link rel="stylesheet" href="/static/css/admonition_972c50a2320249eebf61150270d503dc.css" /></head><body class="d-flex flex-column min-vh-100"><div id="sidebar-expander" class="sidebar_expander"><i class="fa-regular fa-square-caret-right"></i></div><nav class="navbar navbar-expand-md navbar-light fixed-top bg-light"><div class="container-fluid"><a class="navbar-brand navbar-slash" href="/">bishabosha</a><button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav me-auto"><li class="nav-item"><a class="nav-link" href="/about/">About</a></li><li class="nav-item"><a class="nav-link active" aria-current="page" href="/articles/">Articles</a></li><li class="nav-item"><a class="nav-link" href="/projects/">Projects</a></li><li class="nav-item"><a class="nav-link" href="/talks/">Talks</a></li></ul></div></div></nav><div class="container"><div class="row"><div class="col-lg-4"><div class="bio-box jumbotron sidebar shadow py-lg-4 py-3 bio-box__top"><div class="bio-main"><table><tr><td class="bio-left"><div class="bio-photo"><img src="/static/img/jamie_thompson_profile.png" alt="photo of bishabosha" class="img-avatar" /></div></td><td class="bio-right"><p><span class="bio-name">Jamie Thompson</span></p></td></tr></table><ul class="list-inline"><li class="list-inline-item"><p class="text-center mb-1"><small><a href="mailto:jamie.thompson@bath.edu" class="bio-link"><i class="fa-solid fa-envelope fa-lg"></i><br />E-Mail</a></small></p></li><li class="list-inline-item"><p class="text-center mb-1"><small><a href="https://github.com/bishabosha" class="bio-link" rel="me"><i class="fa-brands fa-github fa-lg"></i><br />GitHub</a></small></p></li><li class="list-inline-item"><p class="text-center mb-1"><small><a href="https://twitter.com/bishabosha" class="bio-link" rel="me"><i class="fa-brands fa-twitter fa-lg"></i><br />Twitter</a></small></p></li><li class="list-inline-item"><p class="text-center mb-1"><small><a href="https://www.linkedin.com/in/james-richard-thompson/" class="bio-link" rel="me"><i class="fa-brands fa-linkedin fa-lg"></i><br />LinkedIn</a></small></p></li><li class="list-inline-item"><p class="text-center mb-1"><small><a href="https://fosstodon.org/@jrthompson" class="bio-link" rel="me"><i class="fa-brands fa-mastodon fa-lg"></i><br />Mastodon</a></small></p></li></ul><div class="d-none d-sm-none d-lg-block"><hr /><div class="bio-body bio-expand" tabindex="0"><p>Compiler hacker. This is an archive for my thoughts on programming, past and future.</p>
<p>Also a place to gather all the links.</p>
<p><a href="https://jamie-thompson-dev.github.io/"><strong>professional enquiries</strong></a>.</p>
</div></div></div></div><div id="sidebar-anchor" class="sticky-top top-aligned jumbotron sidebar sidebar__mobile shadow py-lg-4 py-3"><div id="sidebar-toggler" class="sidebar_toggle"><i class="fa-regular fa-square-caret-right"></i></div><div id="toc-toggler" class="toc_toggle"><i class="fa-regular fa-square-caret-down"></i></div><nav class="toc-nav"><ol class="list-unstyled"><li class="toc-level-1"><a href="#understanding-match-types-in-scala-3.html">Understanding Match Types in Scala 3</a></li><li class="toc-level-2"><a href="#what-are-match-types">What are Match Types?</a></li><li class="toc-level-2"><a href="#example-use-cases">Example Use Cases</a></li><li class="toc-level-3"><a href="#type-safe-routing">Type-Safe Routing</a></li><li class="toc-level-3"><a href="#refined-types">Refined types</a></li><li class="toc-level-3"><a href="#lenses-for-form-data">Lenses for Form Data</a></li><li class="toc-level-2"><a href="#the-rules">The Rules</a></li><li class="toc-level-3"><a href="#subtype-checking">Subtype Checking</a></li><li class="toc-level-3"><a href="#disjointness-checking">Disjointness Checking</a></li><li class="toc-level-3"><a href="#dependent-methods">Dependent Methods</a></li><li class="toc-level-3"><a href="#more-disjointness-examples">More Disjointness Examples</a></li><li class="toc-level-3"><a href="#recursive-match-types">Recursive Match Types</a></li><li class="toc-level-2"><a href="#built-in-compile-time-operations">Built-in Compile-Time Operations</a></li><li class="toc-level-2"><a href="#summary-and-remarks">Summary and Remarks</a></li></ol></nav></div></div><div class="col-lg-8 main-content"><div class="jumbotron bg-light py-lg-5 py-3"><article><h1 id="understanding-match-types-in-scala-3.html" class="display-5 anchor-link__source">Understanding Match Types in Scala 3</h1><ul class="list-inline mb-2"><li class="list-inline-item"><small><span class="text-muted">Saturday, 30 August 2025</span></small></li><li class="list-inline-item"><small><i class="fa-solid fa-hourglass-start"></i> 7 minute read</small></li><li class="list-inline-item"><small><a href="/articles/"><i class="fa-solid fa-angle-up"></i> all articles</a></small></li></ul><hr /><div class="container mb-2"><div class="row"><div class="col d-flex"><small><a href="/articles/scalasql-simpletable.html"><i class="fa-solid fa-angle-left"></i> Making ScalaSql boring again (with interesting new internals)</a></small></div><div class="col d-flex flex-row-reverse"></div></div></div><div><p>Scala 3 introduced <a href="https://www.scala-lang.org/api/3.7.2/docs/new-types/match-types.html">match types</a>, a powerful feature enabling to perform computations with types at compile time, a technique known as type-level programming. This post gives an overview of how they work, and what kinds of use cases they can be applied to.</p>
<blockquote>
<p>This post mirrors my talk from ScalaDays 2025. Explore code examples in the <a href="https://github.com/bishabosha/scaladays-2025">demo repo</a>. Also try out the <a href="/match-type-simulator/">interactive demo</a>.</p>
</blockquote>
<h2><a href="#what-are-match-types" id="what-are-match-types" class="anchor-link anchor-link__source"><i class="fa-solid fa-link"></i></a>What are Match Types?</h2>
<p>A match type allows you to compare a type to various patterns and produce a result type based on the matching pattern.</p>
<p>Here is the syntax: <code>T match { case P[x] =&gt; U }</code>, where <code>T</code> is the scrutinee type, <code>P[x]</code> is a pattern with a type parameter <code>x</code>, and <code>U</code> is the result type.</p>
<p>You can use a match type on the right-hand side of a type alias, or type lambda, making them like a function at the type level.</p>
<p>Let's begin with the identity match type: <code>type Id[T] = T match { case T =&gt; T }</code>:</p>
<iframe src="/match-type-simulator/?embed=true&tab=match-types&example=Identity&stamp=19900ce15ae" width="100%" height="275px"></iframe>
<p>Try to run the simulation with various Scala types as arguments (e.g. <code>String</code>, <code>List[Int]</code>, etc.)</p>
<blockquote>
<p>To assist with my presentation at ScalaDays 2025, I developed a <a href="/match-type-simulator/">match type simulator</a> to explain the rules of match types in a visual way, which you see above.</p>
</blockquote>
<p>Observe that whatever argument you pass to the match type, the result type is the same as the argument type, which makes sense as the only pattern <code>case T =&gt; T</code> is to match directly on the scrutinee itself.</p>
<hr />
<h2><a href="#example-use-cases" id="example-use-cases" class="anchor-link anchor-link__source"><i class="fa-solid fa-link"></i></a>Example Use Cases</h2>
<p>There are a lot more examples in my <a href="https://speakerdeck.com/bishabosha/effective-match-types-scala-days-2025">slides</a>, but I will just highlight three use cases that demonstrate different domains of expressive power.</p>
<h3><a href="#type-safe-routing" id="type-safe-routing" class="anchor-link anchor-link__source"><i class="fa-solid fa-link"></i></a>Type-Safe Routing</h3>
<pre><code class="language-scala">http get &quot;/hello/:name&quot; in:
  s&quot;Hello ${params.name}!&quot;
http get &quot;/posts/?:title&amp;:author&quot; in:
  search(title = params.title, author = params.author)
</code></pre>
<blockquote>
<p>Check out the full example in the <a href="https://github.com/bishabosha/scaladays-2025/blob/main/sinatra/sinatra-demo.scala">demo repo</a>.</p>
</blockquote>
<p>The above example uses a match type to parse the route string and extract a structural type for <code>params</code>, e.g. <code>(name: String)</code>, or <code>(title: Seq[String], author: Seq[String])</code>. This increases type safety because parameters can not be misspelled.</p>
<h3><a href="#refined-types" id="refined-types" class="anchor-link anchor-link__source"><i class="fa-solid fa-link"></i></a>Refined types</h3>
<pre><code class="language-scala">val one: Int Refined AtLeast[0] = 1 // ok
val fail: String Refined MaxChars[8] = &quot;123456789&quot; // error
</code></pre>
<blockquote>
<p>Check out the full example in the <a href="https://github.com/bishabosha/scaladays-2025/blob/main/refined-types/refined-demo.scala">demo repo</a>.</p>
</blockquote>
<p>The <code>Refined</code> type provides an implicit conversion for literal types, if it can prove that a match type predicate such as <code>AtLeast[0]</code> reduces to the the literal type <code>true</code> when applied to the singleton type of the argument. This is useful for example to require constant strings that have a length limit.</p>
<h3><a href="#lenses-for-form-data" id="lenses-for-form-data" class="anchor-link anchor-link__source"><i class="fa-solid fa-link"></i></a>Lenses for Form Data</h3>
<pre><code class="language-scala">case class Form(name: String, city: String)

val formVar = VarLenses(Form(&quot;&quot;, &quot;&quot;))

def cityField = p(
  label(&quot;City: &quot;),
  input(
    placeholder(&quot;Lausanne&quot;),
    controlled(
      value &lt;-- formVar.city.view,
      onInput.mapToValue --&gt; formVar.city.updater
    )
  )
)
</code></pre>
<blockquote>
<p>Check out the full example in the <a href="https://github.com/bishabosha/scaladays-2025/blob/main/laminar-form/demo.scala">demo repo</a>.</p>
</blockquote>
<p>For use with <a href="https://laminar.dev">Laminar</a>,
the <code>VarLenses</code> class reads the structure of any case class, and provides a typed pair of <code>view</code> and <code>updater</code> for each field. This is useful because multiple reactive fields can be controlled from a single place.</p>
<hr />
<h2><a href="#the-rules" id="the-rules" class="anchor-link anchor-link__source"><i class="fa-solid fa-link"></i></a>The Rules</h2>
<h3><a href="#subtype-checking" id="subtype-checking" class="anchor-link anchor-link__source"><i class="fa-solid fa-link"></i></a>Subtype Checking</h3>
<p>The match type reducer works by checking if the scrutinee type (<code>T</code>) is a subtype of any of the pattern cases. If it is, then the case will match, and any wildcard type arguments will be instantiated before reducing to the right-hand side of the case.</p>
<iframe src="/match-type-simulator/?embed=true&tab=match-types&example=Tuple+Unpack&stamp=19900ce15ae" width="100%" height="330px"></iframe>
<p>In the example above, the <code>Tag[x]</code> and <code>Tag[y]</code> patterns will match both <code>ITag.type</code> and <code>STag.type</code> because they are both subtypes of the <code>Tag</code> class, and in the bindings you will see that the type argument <code>x</code> is instantiated to <code>Int</code> for <code>ITag.type</code> and <code>y</code> to <code>String</code> for <code>STag.type</code>.</p>
<hr />
<h3><a href="#disjointness-checking" id="disjointness-checking" class="anchor-link anchor-link__source"><i class="fa-solid fa-link"></i></a>Disjointness Checking</h3>
<p>Ok, how about multiple patterns? The match type reducer attempts to check the scrutinee type against each pattern case <strong>in sequence</strong>. If the first pattern is <strong>not</strong> a subtype of the scrutinee, then the reducer will check the next pattern, and so on.</p>
<iframe src="/match-type-simulator/?embed=true&tab=match-types&custom=true&name=Custom%20Match%20Type&invocation=Elem%5BFuture%5BInt%5D%5D&cases=case%20String%20%3D%3E%20Char%0Acase%20Seq%5Bx%5D%20%3D%3E%20x%0Acase%20Option%5Bx%5D%20%3D%3E%20x&th=86e712d2&showDisjointnessSteps=true&stamp=19900ce15ae" width="100%" height="335px"></iframe>
<p>Working through the <code>Elem[Future[Int]]</code> example:</p>
<ol>
<li>First check that <code>Future[Int]</code> is a subtype of <code>String</code>.</li>
<li>This fails, so the type checker will try to move on to the next pattern. However it must first check that it is safe to do so by checking for <strong>&quot;provable disjointness&quot;</strong> between the pattern and the scrutinee type.</li>
<li><code>Future[Int]</code> is definitely disjoint from <code>String</code> because <code>String</code> is a final class, therefore there is no risk that some possible instantiation of <code>Future[Int]</code> is also a <code>String</code>.</li>
<li>Check that <code>Future[Int]</code> is a subtype of <code>Seq[x]</code>.</li>
<li>This fails, so check that <code>Future[Int]</code> is <strong>provably disjoint</strong> from <code>Seq[x]</code>.</li>
<li>Disjointness check fails =&gt; stop reduction.</li>
</ol>
<p>Disjointness ensures that even though the pattern does not match, there could be <strong>no chance</strong> that a value of the same static type as the scrutinee has a more precise dynamic type that would actually match the pattern.</p>
<p>Why is <code>Future[Int]</code> not disjoint from <code>Seq[x]</code>? because both <code>Future</code> and <code>Seq</code> are traits, meaning that there could be a hypothetical class <code>FutureSeq[T]</code> that extends both <code>Future</code> and <code>Seq</code> 🤯.</p>
<blockquote>
<p>Hint: try <code>Elem[List[Int]]</code> or <code>Elem[Some[String]]</code> and observe how it changes the behavior.</p>
</blockquote>
<hr />
<h3><a href="#dependent-methods" id="dependent-methods" class="anchor-link anchor-link__source"><i class="fa-solid fa-link"></i></a>Dependent Methods</h3>
<p>Why is the disjointness check important? It's because when a match type is used as the result type of a method, the typechecker uses a special dependent-typing mode, for example:</p>
<iframe src="/match-type-simulator/?embed=true&tab=match-types&custom=true&name=Custom%20Match%20Type&invocation=Elem%5BFuture%5BInt%5D%5D&cases=case%20String%20%3D%3E%20Char%0Acase%20Seq%5Bx%5D%20%3D%3E%20x%0Acase%20Option%5Bx%5D%20%3D%3E%20x&th=86e712d2&showDependentMethod=true&hideTimeline=true&stamp=19900ce15ae" width="100%" height="350px"></iframe>
<p>The rule for this mode is so rigid that the method can be mechanically generated from the match type's definition (try interacting with the pattern cases and see yourself 🤓).</p>
<p>The method must take the shape of a pattern match, where each case is a <strong>typed pattern</strong> (i.e. where each pattern is identical to the corresponding pattern in the match type).</p>
<p>What is special is that within the body of a case, the typechecker expects the same type as the body of the corresponding case in the match type.</p>
<p>In order for dependent methods to be sound, match types must reduce in a way that is <strong>consistent with the runtime type checking</strong>.</p>
<p>Therefore if you consider the method <code>elem</code>, if the parameter <code>t</code> is some value of a hypothetical class <code>FutureSeq[T]</code> extending both <code>Future</code> and <code>Seq</code>, then it would match the <code>Seq</code> case.</p>
<p>For this exact reason, match types are conservative, and if disjointness can not be proved, the match type remains unreduced. (This is not always an error, only if the use site requires a more precise type).</p>
<hr />
<h3><a href="#more-disjointness-examples" id="more-disjointness-examples" class="anchor-link anchor-link__source"><i class="fa-solid fa-link"></i></a>More Disjointness Examples</h3>
<p>According to the <a href="https://scala-lang.org/files/archive/spec/3.4/03-types.html#match-types">Scala 3 language specification</a>, provable disjointness can be intuitively understood by knowing the following properties of Scala's type system:</p>
<blockquote>
<ul>
<li>Single inheritance of classes</li>
<li>Final classes cannot be extended</li>
<li>Sealed traits have a known set of direct children</li>
<li>Constant types with distinct values are nonintersecting</li>
<li>Singleton paths to distinct enum case values are nonintersecting</li>
</ul>
</blockquote>
<p>Here are some examples that demonstrate these properties:</p>
<blockquote>
<p>Hint: try changing the types in any of the examples.</p>
</blockquote>
<iframe src="/match-type-simulator/?embed=true&tab=disjointness&example=Abstract+Type+vs+Concrete&stamp=19900ce15ae" width="100%" height="180px"></iframe>
<iframe src="/match-type-simulator/?embed=true&tab=disjointness&example=Two+Traits&stamp=19900ce15ae" width="100%" height="200px"></iframe>
<iframe src="/match-type-simulator/?embed=true&tab=disjointness&example=Trait+vs+Class&stamp=19900ce15ae" width="100%" height="215px"></iframe>
<iframe src="/match-type-simulator/?embed=true&tab=disjointness&example=Trait+vs+Final+Class&stamp=19900ce15ae" width="100%" height="200px"></iframe>
<iframe src="/match-type-simulator/?embed=true&tab=disjointness&example=Trait+vs+Object&stamp=19900ce15ae" width="100%" height="180px"></iframe>
<iframe src="/match-type-simulator/?embed=true&tab=disjointness&example=Sealed+Trait+vs+Class&stamp=19900ce15ae" width="100%" height="200px"></iframe>
<iframe src="/match-type-simulator/?embed=true&tab=disjointness&example=Two+Unrelated+Classes&stamp=19900ce15ae" width="100%" height="180px"></iframe>
<blockquote>
<p>Hint: try changing the types in any of the examples above.</p>
</blockquote>
<hr />
<h3><a href="#recursive-match-types" id="recursive-match-types" class="anchor-link anchor-link__source"><i class="fa-solid fa-link"></i></a>Recursive Match Types</h3>
<p>A last demonstration of the capabilities of match types is the ability to express recursive types.
With recursion, you can compute true algorithms over types. For example, we can compute the last element of a tuple:</p>
<iframe src="/match-type-simulator/?embed=true&tab=match-types&example=Last+Tuple+Element&stamp=19900ce15ae" width="100%" height="360px"></iframe>
<p>Recursion is the key to most useful match types - for example it is used in the <a href="#type-safe-routing">Type Safe Routing</a> example to traverse each character of a path string.</p>
<hr />
<h2><a href="#built-in-compile-time-operations" id="built-in-compile-time-operations" class="anchor-link anchor-link__source"><i class="fa-solid fa-link"></i></a>Built-in Compile-Time Operations</h2>
<p>Scala 3 comes with a set intrinsic match types known as <strong>compile-time operations</strong>, living in the <code>scala.compiletime.ops</code> package.</p>
<pre><code class="language-scala">import scala.compiletime.ops.any.*
import scala.compiletime.ops.string.*
import scala.compiletime.ops.int.*
import scala.compiletime.ops.boolean.*

(23 match {case S[n] =&gt; n}) =:= 22
(64 == 128)                 =:= false
(&quot;sca&quot; + &quot;la&quot;)              =:= &quot;scala&quot;
Substring[&quot;scala&quot;, 3, 5]    =:= &quot;la&quot;
CharAt[&quot;scala&quot;, 1]          =:= 'c'
Length[&quot;scala&quot;]             =:= 5
</code></pre>
<p>These are particularly efficient for implementing match types that compute over <strong>literal types</strong>,
with operations for:</p>
<ul>
<li>Numerics</li>
<li>Bit Manipulation</li>
<li>Boolean logic</li>
<li>String parsing</li>
<li>Equality checking</li>
</ul>
<p>To use these in a match type, typically you would call one as the scrutinee of a match type, and match on the result. The following snippet is taken from the <a href="#type-safe-routing">Type Safe Routing</a> example:</p>
<pre><code class="language-scala">type SearchChar[
    C &lt;: Char,
    Str &lt;: String,
    Idx &lt;: Int
] &lt;: Option[Int] =
  (Length[Str] == Idx) match
    case true  =&gt;
      None.type
    case false =&gt;
      (CharAt[Str, Idx] == C) match
        case true =&gt; Some[Idx]
        case false =&gt; SearchChar[C, Str, S[Idx]]

// usage: search for ':' in &quot;/hello/:user&quot;
SearchChar[':', &quot;/hello/:user&quot;, 0] =:= Some[7]
// usage: search for '?' in &quot;/hello/:user&quot;
SearchChar['?', &quot;/hello/:user&quot;, 0] =:= None.type
</code></pre>
<hr />
<p>Also particularly useful is the <code>NamedTuple.From</code> intrinsic type, which converts a case class type into a named tuple type:</p>
<pre><code class="language-scala">case class Person(name: String, age: Int)

NamedTuple.From[Person] =:= (name: String, age: Int)
</code></pre>
<p>These can be further modified with tuple match types from the standard library, such as <code>NamedTuple.Map</code>.</p>
<hr />
<h2><a href="#summary-and-remarks" id="summary-and-remarks" class="anchor-link anchor-link__source"><i class="fa-solid fa-link"></i></a>Summary and Remarks</h2>
<p>I hope this article was useful for you to get a better understanding for how match types work in Scala 3.</p>
<p>Again you can look at the demo repository <a href="https://github.com/bishabosha/scaladays-2025">here</a>, which contains full examples of match types, and also a benchmark comparing the performance with implicits.</p>
</div><div class="container mb-2"><div class="row"><div class="col d-flex"><small><a href="/articles/scalasql-simpletable.html"><i class="fa-solid fa-angle-left"></i> Making ScalaSql boring again (with interesting new internals)</a></small></div><div class="col d-flex flex-row-reverse"></div></div></div></article></div></div></div></div><footer class="mt-auto"><div class="footer-copyright text-center py-3"><small>© 2025 Jamie Thompson.<span class="text-muted"> Last published 31/Aug/2025</span></small></div></footer><script src="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/js/bootstrap.bundle.min.js" integrity="sha384-MrcW6ZMFYlzcLA8Nl+NtUVF0sA7MsXsP1UyJoMp4YLEuNSfAP+JcXn/tWtIaxVXM" crossorigin="anonymous"></script><script src="/static/js/nav-toc_59f8aa56504c2ecea884f7d87ca0a962.js" type="text/javascript"></script><script src="/static/js/sidebar-mobile_63c21c40d63ae89bd8880d2e1b3dc2c9.js" type="text/javascript"></script><script src="/static/js/toc-collapse_53e0696ec44f972d1bb26303d9fc65b7.js" type="text/javascript"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.5.1/highlight.min.js" type="text/javascript"></script><script src="/static/js/hljs-scala3_868eb64187ff110dc72ccc6085774ee9.js" type="text/javascript"></script><script src="/static/js/hljs_a6372cedaa54e6ef1cd502062aef22a1.js" type="text/javascript"></script><script src="/static/js/katex-render_ea5696b3297f767be055588a9afda5ce.js" type="text/javascript"></script><script src="/static/js/admonition_70fb98d2c3c7311ff9783fd7412c7132.js" type="text/javascript"></script></body></html>